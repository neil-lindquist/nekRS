
void lagrange_eval(double *p, double *data,
                   unsigned int n, double x,
                   unsigned int i)
{
  if (i < n) {
    const double *z=data, *w=z+n;
    double p_i = 1;
    for (unsigned int j = 0; j < n; ++j) {
      double d_j = 2*(x-z[j]);
      p_i *= j==i ? 1 : d_j;
    }
    p[i] = w[i] * p_i;
  }
}



@kernel void findpts_el_eval_2(
        double *const out_base, const unsigned int out_stride,
  const double *const   r_base, const unsigned int   r_stride,
  const unsigned int pn, const double *const in,
  const unsigned int nr, const unsigned int ns,
        double *lag_data_0, double *lag_data_1)
{
  unsigned int inner_size = max(nr, ns);

  for (unsigned int i = 0; i<pn; ++i; @outer){

    @shared double wtr[MAX_GLL_N];
    @shared double wts[MAX_GLL_N];
    @shared double sums[MAX_GLL_N];

    const double *r = r_base + r_stride*i;
    for (unsigned int j = 0; j < inner_size; ++j; @inner) {
      lagrange_eval(wtr, lag_data_0, nr, r[0], j);
      lagrange_eval(wts, lag_data_1, ns, r[1], j);
    }

    // tensor_mxm(slice, nr, in, ns, wts, pn)
    // tensor_i1(wtr, nr, slice)

    // out[i] = sum_j sum_k wts[j]*wtr[k]*in[j + k*nr]
    for (unsigned int j = 0; j < inner_size; ++j; @inner) {
      if (j < nr) {
        double sum = 0;
        const double *in_j = in+j;

        for (unsigned int k = 0; k < ns; ++k) {
          sum += in_j[k*nr] * wts[k];
        }
        sums[j] = wtr[j]*sum;
      } else {
        sums[j] = 0.0;
      }
    }

    double *out = out_base + out_stride*i;

// MAX_GLL_N is assumed to be at most 256
#if MAX_GLL_N>128
    for (unsigned int j = 0; j < inner_size; ++j; @inner) {
      if (j < 128 && j + 128 < nr) {
        sums[j] += sums[j+128];
      }
    }
#endif
#if MAX_GLL_N>64
    for (unsigned int j = 0; j < inner_size; ++j; @inner) {
      if (j < 64 && j + 64 < nr) {
        sums[j] += sums[j+64];
      }
    }
#endif
#if MAX_GLL_N>32
    for (unsigned int j = 0; j < inner_size; ++j; @inner) {
      if (j < 32 && j + 32 < nr) {
        sums[j] += sums[j+32];
      }
    }
#endif
    for (unsigned int j = 0; j < inner_size; ++j; @inner) {
      if (j < 16 && j + 16 < nr) {
        sums[j] += sums[j+16];
      }
    }
    for (unsigned int j = 0; j < inner_size; ++j; @inner) {
      if (j < 4 && j + 4 < nr) {
        sums[j] += sums[j+4];
      }
    }
    for (unsigned int j = 0; j < inner_size; ++j; @inner) {
      if (j < 2 && j + 2 < nr) {
        sums[j] += sums[j+2];
      }
    }
    for (unsigned int j = 0; j < inner_size; ++j; @inner) {
      if (j == 0 && 1 < nr) {
        *out = sums[0] + sums[1];
      }
    }
  }
}

@kernel void findpts_el_eval_3(
        double *const out_base, const unsigned int out_stride,
  const double *const   r_base, const unsigned int   r_stride,
  const unsigned int pn, const double *const in,
  const unsigned int nr, const unsigned int ns, const unsigned int nt,
        double *lag_data_0, double *lag_data_1, double *lag_data_2)
{
  unsigned int j, inner_size = max(nr, ns);

  for (unsigned int i = 0; i<pn; ++i; @outer){

    @shared double wtr[MAX_GLL_N];
    @shared double wts[MAX_GLL_N];
    @shared double wtt[MAX_GLL_N];
    @shared double sums[MAX_GLL_N]; // could be overlaped with wtt

    const double *r = r_base + r_stride*i;
    for (unsigned int j = 0; j < inner_size; ++j; @inner) {
      lagrange_eval(wtr, lag_data_0, nr, r[0], j);
      lagrange_eval(wts, lag_data_1, ns, r[1], j);
      lagrange_eval(wtt, lag_data_2, nt, r[2], j);
    }

    // tensor_mxm(slice, nr*ns, in, nt, wtt, pn)
    // tensor_i2(wtr, nr, wts, ns, slice, sums)
    //   computes wtr^T * slice * wts w/ wtr and wts vectors, and slice matrix

    // out[i] = sum_j sum_k sum_l wtr[j]*wts[k]*wtt[l]*in[j + k*nr + l*nr*ns]
    //        = sum_j wtr[j] * sum_k wts[k] * sum_l wtt[l]*in[j + k*nr + l*nr*ns]
    for (unsigned int j = 0; j < inner_size; ++j; @inner) {
      if (j < nr) {
        double sum_j = 0;
        const double *in_j = in+j;
        for (unsigned int k = 0; k < ns; ++k) {
          double sum_k = 0;
          const double *in_jk = in_j+k*nr;

          for (unsigned int l = 0; l < nt; ++l) {
            sum_k += in_jk[l*nr*ns] * wtt[l];
          }
          sum_j += wts[k]*sum_k;
        }
        sums[j] = wtr[j]*sum_j;
      } else {
        sums[j] = 0.0;
      }
    }

    double *out = out_base + out_stride*i;

// MAX_GLL_N is assumed to be at most 256
#if MAX_GLL_N>128
    for (unsigned int j = 0; j < inner_size; ++j; @inner) {
      if (j < 128 && j + 128 < nr) {
        sums[j] += sums[j+128];
      }
    }
#endif
#if MAX_GLL_N>64
    for (unsigned int j = 0; j < inner_size; ++j; @inner) {
      if (j < 64 && j + 64 < nr) {
        sums[j] += sums[j+64];
      }
    }
#endif
#if MAX_GLL_N>32
    for (unsigned int j = 0; j < inner_size; ++j; @inner) {
      if (j < 32 && j + 32 < nr) {
        sums[j] += sums[j+32];
      }
    }
#endif
    for (unsigned int j = 0; j < inner_size; ++j; @inner) {
      if (j < 16 && j + 16 < nr) {
        sums[j] += sums[j+16];
      }
    }
    for (unsigned int j = 0; j < inner_size; ++j; @inner) {
      if (j < 4 && j + 4 < nr) {
        sums[j] += sums[j+4];
      }
    }
    for (unsigned int j = 0; j < inner_size; ++j; @inner) {
      if (j < 2 && j + 2 < nr) {
        sums[j] += sums[j+2];
      }
    }
    for (unsigned int j = 0; j < inner_size; ++j; @inner) {
      if (j == 0 && 1 < nr) {
        *out = sums[0] + sums[1];
      }
    }
  }
}
