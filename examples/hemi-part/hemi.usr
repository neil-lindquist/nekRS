c- CASE PARAMETERS------------------------------------------------------

#define INTP_NMAX 4000
#define LPART INTP_NMAX /* max number of particles per MPI rank */
c-----------------------------------------------------------------------
      subroutine uservp (ix,iy,iz,ieg)
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'

      udiff  = 0
      utrans = 0

      return
      end
c-----------------------------------------------------------------------
      subroutine userf  (ix,iy,iz,ieg)
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'

      ffx = 0.0
      ffy = 0.0
      ffz = 0.0

      return
      end
c-----------------------------------------------------------------------
      subroutine userq  (ix,iy,iz,ieg)
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'

      qvol   = 0.0

      return
      end
c-----------------------------------------------------------------------
      subroutine userchk
      include 'SIZE'
      include 'TOTAL'

      if (ifoutfld) call lambda2(t)

      call my_particle_generator(ifoutfld)             ! Particle injection

      return
      end
c-----------------------------------------------------------------------
      subroutine useric (ix,iy,iz,ieg)
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'

      c1 = pi * 0.5/0.6

      arg = c1*z
      if (arg.gt.0.5*pi) then
        ux = 1.0
      else
        ux = sin(arg)
      endif

      uy=0.0
      uz=0.0

      return
      end
c-----------------------------------------------------------------------
      subroutine usrdat3
      include 'SIZE'
      include 'TOTAL'

      ifto = .true. ! required to lambda2

      return
      end
c-----------------------------------------------------------------------
      subroutine usrdat2
      include 'SIZE'
      include 'TOTAL'

      logical ifaln,ifnorx,ifnory,ifnorz

      do iel=1,nelt
      do ifc=1,2*ndim
         if (cbc(ifc,iel,1) .eq. 'v  ') boundaryID(ifc,iel) = 1
         if (cbc(ifc,iel,1) .eq. 'O  ') boundaryID(ifc,iel) = 2
         if (cbc(ifc,iel,1) .eq. 'W  ') boundaryID(ifc,iel) = 3
         if (cbc(ifc,iel,1) .eq. 'SYM') then
            call chknord(ifaln,ifnorx,ifnory,ifnorz,ifc,iel)
            boundaryid(ifc,iel) = 4
            if (ifnorz) boundaryid(ifc,iel) = 5
         endif
      enddo
      enddo

      return
      end
c-----------------------------------------------------------------------
      subroutine usrdat
      return
      end
c-----------------------------------------------------------------------
      subroutine interp_v(uvw,xyz,n)
c
c     evaluate velocity for list of points xyz
c
      include 'SIZE'
      include 'TOTAL'

      real uvw(ldim,n),xyz(ldim,n)

      real    rwk(INTP_NMAX,ldim+1) ! r, s, t, dist2
      integer iwk(INTP_NMAX,3)      ! code, proc, el
      save    rwk, iwk

      integer intp_h
      save    intp_h

      common /rwk_intp/
     $       fwrk(lx1*ly1*lz1*lelt,ldim),
     $       fpts(ldim*INTP_NMAX),
     $       pts(ldim*INTP_NMAX)

      integer icalld,e
      save    icalld
      data    icalld /0/

      nxyz  = nx1*ny1*nz1
      ntot  = nxyz*nelt

      if (n.gt.INTP_NMAX) call exitti ('n > INTP_NMAX in interp_v!$',n)

      if (nelgt.ne.nelgv) call exitti
     $   ('nelgt.ne.nelgv not yet supported in interp_v!$',nelgv)

      do i=1,n                   ! ? not moving -> save?
         pts(i)     = xyz(1,i)
         pts(i + n) = xyz(2,i)
         if (if3d) pts(i + n*2) = xyz(3,i)
      enddo

      if (icalld.eq.0) then
        icalld = 1
        call interp_setup(intp_h,0.0,0,nelt)
      endif

      ! pack working array
      call opcopy(fwrk(1,1),fwrk(1,2),fwrk(1,3),vx,vy,vz)

      ! interpolate
      call interp_nfld(fpts,fwrk,ndim,pts(1),pts(1+n),pts(2*n+1),
     $                 n,iwk,rwk,INTP_NMAX,.true.,intp_h)

      do i=1,n
         uvw(1,i) = fpts(i)
         uvw(2,i) = fpts(i + n)
         if(if3d) uvw(3,i) = fpts(i + n*2)
      enddo

      return
      end
c-----------------------------------------------------------------------
      subroutine particle_advect_std(x,vh,partv,npart)

c     Lagrangian particle advection

      include 'SIZE'
      include 'TOTAL'

      real x(ldim,LPART),vh(ldim,2:3,LPART),partv(LPART)
      common /scruz/ u1(ldim,LPART)

      common /padvc/ xmx(3,0:2)

      real    last_time
      save    last_time
      data    last_time  /0/

      if (istep.eq.0) then      ! AB1
         call rzero(vh,3*ndim*npart)
         c1 = 1.
         c2 = 0.
         c3 = 0.
      elseif (istep.eq.1) then  ! AB2
         c1 = 3
         c2 = -1.
         c3 = 0
         c1 = c1/2.
         c2 = c2/2.
      else                    ! AB3
         c1 = 23.
         c2 = -16.
         c3 = 5.
         c1 = c1/12.
         c2 = c2/12.
         c3 = c3/12
      endif


      dt = time - last_time
      last_time = time

      call interp_v(u1,x,npart)

      do i=1,npart
      do k=1,ndim
C     Update particle position and history
           x(k,i) = x(k,i)
     $              + dt*(c1*u1(k,i) + c2*vh(k,2,i) + c3*vh(k,3,i))
C     Update particle and fluid velocity history
           vh(k,3,i) = vh(k,2,i)
           vh(k,2,i) = u1(k,i)
      enddo
      enddo

      return
      end
c----------------------------------------------------------------------
      subroutine particle_out (x,partid,partv,npart,ifoutpart)
      include 'SIZE'
      include 'TOTAL'

      real x(ldim,LPART),partv(LPART)
      integer partid(LPART)
      logical ifoutpart

      common /scrns/ x_tmp(ldim+1,LPART),work(ldim+1,LPART)

      character*128 fname

      integer icalld
      save    icalld
      data    icalld  /0/

      if (.not. ifoutpart) return

      icalld = icalld+1
      if (nid.eq.0) then
        write(fname,1) icalld
 1      format('part',i5.5,'.3D')
        open(unit=72,file=fname)
      endif

      min_points = iglmin(partid,npart)
      max_points = iglmax(partid,npart)
      n_active   = max_points - min_points + 1
      npass = n_active / LPART
      if (n_active.gt.npass*LPART) npass = npass+1
      ilast=min_points-1

        if (nid.eq.0) write(72,*)"X Y Z Color"

      do ipass=1,npass

        mpart = min(LPART,max_points-ilast)
        i0    = ilast
        i1    = i0 + mpart
        ilast = i1

        call rzero(x_tmp,(ldim+1)*LPART)
        do ii=1,npart
          if (i0.lt.partid(ii).and.partid(ii).le.i1) then
            i = partid(ii)-i0
            call copy(x_tmp(1,i),x(1,ii),ldim)  ! Coordinates
            x_tmp(ldim+1,i) = partv(ii)         ! Store value here
          endif
        enddo

        call gop(x_tmp,work,'+  ',(ldim+1)*LPART)
        if (nid.eq.0) write(72,2)((x_tmp(k,i),k=1,ldim+1),i=1,mpart)
 2      format(1p4e17.9)

      enddo

      if (nid.eq.0) close(72)

      return
      end
C-----------------------------------------------------------------------
      subroutine my_particle_generator(ifoutpart) ! Particle injection
      include 'SIZE'
      include 'TOTAL'
      include 'mpif.h'

      logical ifoutpart

      common /rparts/ pts(ldim,LPART),vel(ldim,2:3,LPART),partv(LPART)
      common /iparts/ npart,partid(LPART)
      integer partid

      real ptime           ! Time the particle motion
      save ptime
      data ptime  /0./

      ptime0 = dnekclock_sync()

      call particle_init       (pts,partid,partv,npart,ifoutpart)
      call particle_advect_std (pts,vel,partv,npart)
      call particle_out        (pts,partid,partv,npart,ifoutpart)

      ptime1 = dnekclock_sync() ! Track computational cost of particles

      dptime = (ptime1-ptime0)
      ptime  = ptime + dptime

      if (ifoutpart) then
         npmin = iglmin(npart,1)
         npmax = iglmax(npart,1)
         nptot = iglsum(npart,1)
         npmav = nptot/np
         ptpp  = dptime / nptot  ! particle-time per point
         if (nid.eq.0) write(6,1)
     $      istep,npmin,npmav,npmax,nptot,ptpp,dptime,ptime,time
    1       format(4i7,i9,1p4e15.7,' ptime')
      endif

      return
      end
c-----------------------------------------------------------------------
      subroutine particle_init(x,partid,partv,npart,ifoutpart)
c
c     This version does continuous injection and overwrites old entries
c
      include 'SIZE'
      include 'TOTAL'

      real x(ldim,LPART),partv(LPART)
      integer partid(LPART)
      logical ifoutpart

      integer lcount,icount
      save    lcount,icount
      data    lcount,icount /0,0/

      if ((.not. ifoutpart).or.(istep.eq.0)) return

      lLPART = LPART

      dx = 0.05
      dy = .025
      ds = (1-dy)/100

      k0 = 0
      k  = icount       ! icount = total # particles emitted
      l  = lcount       ! Index into local particle array

      nw = 200

      do iline = 1,4    ! 4 lines at different heights
        xp = -2.5
        zp = .05 + (iline-1)*0.075
        do ipart = 1,nw  ! nw points on a wire

         dy =  1.0*2/(nw-1)
         yp = -1.0 + dy*(ipart-1)

         if (mod(k,np).eq.nid) then ! Inject particle _only_ on this processor
            l=l+1  ! local count
            if (l.gt.lLPART) l=1 ! Retire old particles by overwriting their data
            x(1,l) = xp
            x(2,l) = yp
            x(3,l) = zp
            partid(l) = k+1
c           partv(l) = time  ! A simple coloring scheme
c           partv(l) = k0    ! Another simple coloring scheme
            partv(l) = iline ! color by line
         endif

         k = k+1     ! Total count

      enddo

      k0= k0+1    ! Count for this release (for coloring only)

      enddo

      icount = k
      lcount = l
      npart  = max(npart,lcount)

      return
      end
c-----------------------------------------------------------------------
