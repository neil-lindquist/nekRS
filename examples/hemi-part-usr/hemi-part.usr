c- CASE PARAMETERS------------------------------------------------------

#define INTP_NMAX 4000
#define LPART INTP_NMAX /* max number of particles per MPI rank */
c-----------------------------------------------------------------------
      subroutine uservp (ix,iy,iz,ieg)
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'

      udiff  = 0
      utrans = 0

      return
      end
c-----------------------------------------------------------------------
      subroutine userf  (ix,iy,iz,ieg)
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'

      ffx = 0.0
      ffy = 0.0
      ffz = 0.0

      return
      end
c-----------------------------------------------------------------------
      subroutine userq  (ix,iy,iz,ieg)
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'

      qvol   = 0.0

      return
      end
c-----------------------------------------------------------------------
      subroutine userchk
      include 'SIZE'
      include 'TOTAL'

      if (ifoutfld) call lambda2(t)

      call my_particle_generator(ifoutfld)             ! Particle injection

      return
      end
c-----------------------------------------------------------------------
      subroutine useric (ix,iy,iz,ieg)
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'

      c1 = pi * 0.5/0.6

      arg = c1*z
      if (arg.gt.0.5*pi) then
        ux = 1.0
      else
        ux = sin(arg)
      endif

      uy=0.0
      uz=0.0

      return
      end
c-----------------------------------------------------------------------
      subroutine usrdat3
      include 'SIZE'
      include 'TOTAL'

      ifto = .true. ! required to lambda2

      return
      end
c-----------------------------------------------------------------------
      subroutine usrdat2
      include 'SIZE'
      include 'TOTAL'

      logical ifaln,ifnorx,ifnory,ifnorz

      do iel=1,nelt
      do ifc=1,2*ndim
         if (cbc(ifc,iel,1) .eq. 'v  ') boundaryID(ifc,iel) = 1
         if (cbc(ifc,iel,1) .eq. 'O  ') boundaryID(ifc,iel) = 2
         if (cbc(ifc,iel,1) .eq. 'W  ') boundaryID(ifc,iel) = 3
         if (cbc(ifc,iel,1) .eq. 'SYM') then
            call chknord(ifaln,ifnorx,ifnory,ifnorz,ifc,iel)
            boundaryid(ifc,iel) = 4
            if (ifnorz) boundaryid(ifc,iel) = 5
         endif
      enddo
      enddo

      return
      end
c-----------------------------------------------------------------------
      subroutine usrdat
      return
      end
c-----------------------------------------------------------------------
      subroutine interp_v(uvw,xyz,n)
c
c     evaluate velocity for list of points xyz
c
      include 'SIZE'
      include 'TOTAL'

      real uvw(ldim,n),xyz(ldim,n)

      real    rwk(INTP_NMAX,ldim+1) ! r, s, t, dist2
      integer iwk(INTP_NMAX,3)      ! code, proc, el
      save    rwk, iwk

      integer intp_h
      save    intp_h

      common /rwk_intp/
     $       fwrk(lx1*ly1*lz1*lelt,ldim),
     $       fpts(ldim*INTP_NMAX),
     $       pts(ldim*INTP_NMAX)

      integer icalld,e
      save    icalld
      data    icalld /0/

      nxyz  = nx1*ny1*nz1
      ntot  = nxyz*nelt

      if (n.gt.INTP_NMAX) call exitti ('n > INTP_NMAX in interp_v!$',n)

      if (nelgt.ne.nelgv) call exitti
     $   ('nelgt.ne.nelgv not yet supported in interp_v!$',nelgv)

      do i=1,n                   ! ? not moving -> save?
         pts(i)     = xyz(1,i)
         pts(i + n) = xyz(2,i)
         if (if3d) pts(i + n*2) = xyz(3,i)
      enddo

      if (icalld.eq.0) then
        icalld = 1
        call interp_setup(intp_h,0.0,0,nelt)
      endif

      ! pack working array
      call opcopy(fwrk(1,1),fwrk(1,2),fwrk(1,3),vx,vy,vz)

      ! interpolate
      call interp_nfld(fpts,fwrk,ndim,pts(1),pts(1+n),pts(2*n+1),
     $                 n,iwk,rwk,INTP_NMAX,.true.,intp_h)

      do i=1,n
         uvw(1,i) = fpts(i)
         uvw(2,i) = fpts(i + n)
         if(if3d) uvw(3,i) = fpts(i + n*2)
      enddo

      return
      end
c-----------------------------------------------------------------------
      subroutine particle_advect_std(x,valid,vhist,npart)

c     Lagrangian particle advection

      include 'SIZE'
      include 'TOTAL'

      real x(ldim,LPART),vhist(ldim,2:3,LPART)
      logical valid(LPART)
      common /scruz/ u1(ldim,LPART)

      common /padvc/ xmx(3,0:2)

      real    last_time
      save    last_time
      data    last_time  /0/


      call interp_v(u1,x,npart)

      if (istep.eq.0) then      ! AB1
         c1 = 1.
         c2 = 0.
         c3 = 0.
      elseif (istep.eq.1) then  ! AB2
         c1 =  3. / 2.
         c2 = -1. / 2.
         c3 =  0. / 2.
      else                    ! AB3
         c1 =  23. / 12.
         c2 = -16. / 12.
         c3 =   5. / 12.
      endif


      dt = time - last_time
      last_time = time

      do i=1,npart
      if (valid(i)) then
        do k=1,ndim
C         Update particle position and velocity history
          x(k,i) = x(k,i)
     $           + dt*(c1*u1(k,i) + c2*vhist(k,2,i) + c3*vhist(k,3,i))
          vhist(k,3,i) = vhist(k,2,i)
          vhist(k,2,i) = u1(k,i)
        enddo

C       Mark particles that have left the region as invalid
C       outflow is at x=15
        valid(i) = x(1, i).le.15
      endif
      enddo

      return
      end
c----------------------------------------------------------------------
      subroutine particle_out (x,valid,partid,partcolor,npart)
      include 'SIZE'
      include 'TOTAL'

      real x(ldim,LPART),partcolor(LPART)
      integer partid(LPART)
      logical valid(LPART)

      common /scrns/ x_tmp(ldim+2,LPART),work(ldim+2,LPART)

      character*128 fname

      integer icalld
      save    icalld
      data    icalld  /0/

      icalld = icalld+1
      if (nid.eq.0) then
        write(fname,1) icalld
 1      format('part',i5.5,'.3D')
        open(unit=72,file=fname)
      endif

      min_points = 999999999
      max_points = -1

      do ipart = 1,npart
        if (valid(i)) then
          if (min_points.gt.partid(i)) min_points = partid(i)
          if (max_points.lt.partid(i)) max_points = partid(i)
        endif
      enddo
      min_points = iglmin(partid,npart)
      max_points = iglmax(partid,npart)

      n_active   = max_points - min_points + 1
      npass = n_active / LPART
      if (n_active.gt.npass*LPART) npass = npass+1
      ilast=min_points-1

      if (nid.eq.0) write(72,*)"X Y Z Color"

      do ipass=1,npass
        mpart = min(LPART,max_points-ilast)
        i0    = ilast
        i1    = i0 + mpart
        ilast = i1

        call rzero(x_tmp,(ldim+2)*LPART)
        do ii=1,npart
          if (valid(ii).and.i0.lt.partid(ii).and.partid(ii).le.i1) then
            i = partid(ii)-i0
            call copy(x_tmp(1,i),x(1,ii),ldim)  ! Coordinates
            x_tmp(ldim+1,i) = partcolor(ii)     ! Store color here
            x_tmp(ldim+2,i) = 1.0               ! Store validity here
          endif
        enddo

        call gop(x_tmp,work,'+  ',(ldim+2)*LPART)
        if (nid.eq.0) then
          do i = 1,mpart
            if (x_tmp(ldim+2,i).ne.0.0) then
              write(72,2)(x_tmp(k,i),k=1,ldim+1)
 2            format(1p4e17.9)
            endif
          enddo
        endif

      enddo

      if (nid.eq.0) close(72)

      return
      end
C-----------------------------------------------------------------------
      subroutine my_particle_generator(ifoutstep) ! Particle injection
      include 'SIZE'
      include 'TOTAL'
      include 'mpif.h'

      logical ifoutstep, ifnewpart

      common /rparts/ pts(ldim,LPART),vhist(ldim,2:3,LPART),color(LPART)
      common /iparts/ npart,id(LPART),valid(LPART)
      logical valid

      real ptime           ! Time the particle motion
      save ptime
      data ptime  /0./

c     adjust to control when particles are generated
      real last_new_time
      save last_new_time
      data last_new_time /0./

      ifnewpart = time - last_new_time.ge.0.5    ! every 0.5 seconds
      if(ifnewpart) last_new_time = time
c     ifnewpart = istep % 100                    ! every 100 iterations
c     ifnewpart = ifoutstep                      ! on the output steps


      if (ifnewpart) call particle_init(pts,valid,id,vhist,color,npart)
      call particle_advect_std         (pts,valid,   vhist,      npart)
      if (ifoutstep) call particle_out (pts,valid,id,      color,npart)

      return
      end
c-----------------------------------------------------------------------
      subroutine particle_init(x,valid,partid,vhist,partcolor,npart)
c
c     This version does continuous injection and overwrites old entries
c
      include 'SIZE'
      include 'TOTAL'

      real x(ldim,LPART),partcolor(LPART),vhist(ldim,2:3,LPART)
      integer partid(LPART)
      logical valid(LPART)

      integer lcount,icount
      save    lcount,icount
      data    lcount,icount /0,0/

      lLPART = LPART

      k  = icount       ! icount = total # particles emitted
      l  = lcount       ! Index into local particle array

      nw = 100

      do iline = 1,4    ! 4 lines at different heights
        xp = -1.5
        zp = .05 + (iline-1)*0.075
        do ipart = 1,nw  ! nw points on a wire

          dy =  1.0*2/(nw-1)
          yp = -1.0 + dy*(ipart-1)

          if (mod(k,np).eq.nid) then ! Inject particle _only_ on this processor
            l=l+1  ! local count
            if (l.gt.lLPART) l=1 ! Retire old particles by overwriting their data
            x(1,l) = xp
            x(2,l) = yp
            x(3,l) = zp
            partid(l) = k+1
            do m = 2,3
               do d = 1,ndim
                  vhist(d,m,l) = 0
               enddo
            enddo
            valid(l) = .true.
c           partcolor(l) = time       ! A simple coloring scheme
c           partcolor(l) = partid(l)  ! Another simple coloring scheme
            partcolor(l) = iline      ! color by line
          endif

          k = k+1     ! Total count
        enddo
      enddo

      icount = k
      lcount = l
      npart  = max(npart,lcount)

      return
      end
c-----------------------------------------------------------------------
