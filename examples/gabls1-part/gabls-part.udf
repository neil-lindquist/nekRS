//
// nekRS User Defined File
//
#include <limits.h>
#include <string.h>
#include <stdio.h>
#include <math.h>
#include "interp.hpp"
#include "udf.hpp"

#include "casedata.h"

#define LPART 4000 /* max number of particles per MPI rank */
#define MAX_D 3

#define USE_HOST_FINDPTS false
#define IF_CHECK_ACCURACY false

/* Particle Functions */
void particle_init(dfloat x[LPART][MAX_D],
                   int partid[LPART],
                   dfloat v_hist[LPART][2][MAX_D],
                   dfloat part_color[LPART],
                   int &npart) {

  static int gcount = 0, lcount = 0;

  int mpi_rank = platform_t::getInstance()->comm.mpiRank;
  int mpi_size = platform_t::getInstance()->comm.mpiCommSize;

  int k  = gcount; // total # particles emitted
  int l  = lcount; // Index into local particle array

  // simple but works w/ Summits 6 GPUs/node
  int m = 30;
  int o = 20;
  int n = mpi_size*LPART/(m*o);

  // spawn LPART particles in [0.5, 3.5]x[0.5, 3.5]x[0.5, 3.5]
  for (int ix = 0; ix <m; ++ix) {
    for (int iy = 0; iy < n; ++iy) {
      for (int iz = 0; iz < o; ++iz) {

        dfloat dx = 3.6/(m-1),  dy = 3.6/(n-1),  dz = 3.6/(o-1);
        dfloat xp = 0.2 + dx*ix, yp = 0.2 + dy*iy, zp = 0.2 + dz*iz;

        if (k%mpi_size == mpi_rank) { // Inject particle _only_ on this processor
          if (l >= LPART) l=0; // Retire old particles by overwriting their data

          x[l][0] = xp;
          x[l][1] = yp;
          x[l][2] = zp;
          partid[l] = k;
          for (int m = 0; m < 2; ++m) for (int d = 0; d < MAX_D; ++d) v_hist[l][m][d] = 0;
  //      part_color[l] = time;      // color by spawning timestep
          part_color[l] = partid[l]; // color by id
  //      part_color[l] = line+1;    // color by line

          ++l; // local count
        }
        ++k; // Total count
      }
    }
  }

  gcount = k;
  lcount = l;
  npart  = std::max(npart,lcount);
}

// copy of interp_velocity, except using host copy of the velocities
void interp_velocity_host(dfloat *uvw_base[], dlong uvw_stride[],
                          dfloat *xyz_base[], dlong xyz_stride[],
                          int n, nrs_t *nrs)
{
  // the interp handle is cached to avoid repeated setups and frees
  static interp_data *interp_handle;
  static bool called = false;
  if (!called || interp_handle->nrs != nrs) {
    if (called) {
      interp_free(interp_handle);
    }
    called = true;
    interp_handle = interp_setup(nrs, 0);
  }

  dlong D = interp_handle->D;
  char *workspace = (char*)malloc(sizeof(dfloat)*n*(D+1) + sizeof(int)*n*3);
  dfloat *rwork = (dfloat*)workspace;
  int    *iwork = (int*)(workspace + sizeof(dfloat)*n*(D+1));

  interp_nfld(nrs->U, nrs->dim,
              xyz_base, xyz_stride, n,
              iwork, rwork, n, true, interp_handle,
              uvw_base, uvw_stride);

  free(workspace);
}


void particle_advect_std(dfloat x[LPART][MAX_D],
                         dfloat v_hist[LPART][2][MAX_D],
                         int npart, nrs_t *nrs, int tstep) {

  static dfloat u1[LPART][MAX_D];

  dlong D = nrs->dim;

  dfloat *u_base[MAX_D], *x_base[MAX_D];
  dlong u_stride[MAX_D], x_stride[MAX_D];
  for (int i = 0; i < D; ++i) {
    u_base[i]   = &u1[0][i];
    u_stride[i] = MAX_D;
    x_base[i]   = &x[0][i];
    x_stride[i] = MAX_D;
  }

  if (USE_HOST_FINDPTS) {
    interp_velocity_host(u_base, u_stride, x_base, x_stride, npart, nrs);
  } else {
    interp_velocity(u_base, u_stride, x_base, x_stride, npart, nrs, IF_CHECK_ACCURACY);
  }

  double c1, c2, c3, dt = nrs->dt[0];
  if (tstep == 0) { // AB1
    c1 = 1.0;
    c2 = 0.0;
    c3 = 0.0;
  } else if (tstep == 1) { // AB2
    c1 =  3.0 / 2.0;
    c2 = -1.0 / 2.0;
    c3 =  0.0 / 2.0;
  } else { // AB3
    c1 =  23.0 / 12.0;
    c2 = -16.0 / 12.0;
    c3 =   5.0 / 12.0;
  }

  for (int i = 0; i < npart; ++i) {
    // Update particle position and velocity history
    for (int k=0; k < D; ++k) {
       x[i][k] += dt*(c1*u1[i][k] + c2*v_hist[i][0][k] + c3*v_hist[i][1][k]);
       v_hist[i][1][k] = v_hist[i][0][k];
       v_hist[i][0][k] = u1[i][k];
    }
    // x and z have periodic boundaries
    if (x[i][0] > 4) x[i][0] -= 4;
    if (x[i][0] < 0) x[i][0] += 4;
    if (x[i][2] > 4) x[i][2] -= 4;
    if (x[i][2] < 0) x[i][2] += 4;
  }
}

void particle_out(dfloat x[LPART][MAX_D],
                  int partid[LPART],
                  dfloat part_color[LPART],
                  int npart, nrs_t *nrs)
{

  static dfloat x_temp[LPART][MAX_D+1];
  static dfloat x_root[LPART][MAX_D+1];

  static int out_step = 0;
  ++out_step;

  dlong D = nrs->dim;
  MPI_Comm mpi_comm = platform_t::getInstance()->comm.mpiComm;
  int mpi_rank = platform_t::getInstance()->comm.mpiRank;
  int mpi_size = platform_t::getInstance()->comm.mpiCommSize;

  std::FILE *file_out;
  if (mpi_rank == 0) {
    char fname[128];
    sprintf(fname, "part%05d.3d", out_step);
    file_out = fopen(fname, "w+");
  }

  int l_min = INT_MAX, l_max = INT_MIN, min_points, max_points;
  for (int i = 0; i < npart; ++i) {
    if (l_min > partid[i]) {
      l_min = partid[i];
    }
    if (l_max < partid[i]) {
      l_max = partid[i];
    }
  }
  MPI_Allreduce(&l_min, &min_points, 1, MPI_INT, MPI_MIN, mpi_comm);
  MPI_Allreduce(&l_max, &max_points, 1, MPI_INT, MPI_MAX, mpi_comm);

  int n_active = max_points - min_points + 1;
  int npass = n_active / LPART;
  if (n_active > npass*LPART) ++npass;
  int ilast=min_points;

  if (mpi_rank == 0) fprintf(file_out, "X Y Z Color\n");

  for (int ipass = 0; ipass < npass; ++ipass) {
    int mpart = std::min(LPART, max_points - ilast+1);
    int i0 = ilast;
    int i1 = i0 + mpart;
    ilast = i1;

    memset(&x_temp[0][0], 0, mpart*(MAX_D+1)*sizeof(dfloat));
    for (int ii=0; ii < npart; ++ii) {
      if (i0 <= partid[ii] && partid[ii] < i1) {
        int i = partid[ii]-i0;
        for (int j = 0; j < D; ++j) {
          x_temp[i][j] = x[ii][j];       // coordinates
        }
        x_temp[i][D] = part_color[ii];   // color
      }
    }

    MPI_Reduce(&x_temp[0][0], &x_root[0][0], mpart*(MAX_D+1), MPI_DFLOAT, MPI_SUM, 0, mpi_comm);
    if (mpi_rank == 0) {
      for (int i = 0; i < mpart; ++i) {
        for (int j = 0; j < D+1; ++j) {
          fprintf(file_out, " %17.9e", x_root[i][j]);
        }
        fprintf(file_out, "\n");
      }
    }
  }

  if (mpi_rank == 0) fclose(file_out);
}


void my_particle_generator(nrs_t *nrs, dfloat time, int tstep) {

  static int npart = 0;
  static int    partid[LPART];
  static dfloat pts[LPART][MAX_D];
  static dfloat v_hist[LPART][2][MAX_D];
  static dfloat part_color[LPART];


  bool ifnewpart;
  // adjust to control when particles are generated
  // static dfloat last_new_time = 0.0;
  // ifnewpart = time - last_new_time >= 0.5; // every 0.5 seconds
  // if(ifnewpart) last_new_time = time;
  // ifnewpart = tstep % 100;                 // every 100 iterations
  // ifnewpart = nrs->isOutputStep;           // on the output steps
  ifnewpart = tstep == 0;                     // only generate particles on the first step

  // Only output particles on output steps to ensure particles match the field files
  bool ifoutpart = nrs->isOutputStep;

  if (ifnewpart) particle_init(pts, partid, v_hist, part_color, npart);
  particle_advect_std         (pts,         v_hist,             npart, nrs, tstep);
  if (ifoutpart) particle_out (pts, partid,         part_color, npart, nrs);
}


/* User Functions */

occa::kernel coriolisKernel;

void userf(nrs_t *nrs, dfloat time, occa::memory o_U, occa::memory o_FU)
{
  mesh_t* mesh = nrs->meshV;
  coriolisKernel(
    mesh->Nlocal,
    nrs->fieldOffset,
    nrs->meshV->o_y,
    nrs->cds->o_S,
    nrs->o_U,
    o_FU);
}


/* UDF Functions */

void UDF_LoadKernels(nrs_t *nrs)
{
  occa::properties& kernelInfo = *nrs->kernelInfo;
  setupAide &options = platform->options;

  dfloat cond;
  options.getArgs("SCALAR00 DIFFUSIVITY", cond);
  const dfloat g = 9.81;
  const dfloat omega = 7.2921159e-5;

  kernelInfo["defines/p_fcor"]      = 2*omega*LREF/UREF * sin(NLAT*M_PI/180);
  kernelInfo["defines/p_bcor"]      = 2*omega*LREF/UREF * cos(NLAT*M_PI/180);
  kernelInfo["defines/p_gacc"]      = LREF*g/(UREF*UREF);
  kernelInfo["defines/p_cond"]      = cond;
  kernelInfo["defines/p_TsGrad"]    = ILSTRENGTH * LREF/TREF;
  kernelInfo["defines/p_T0s"]       = TS0/TREF;
  kernelInfo["defines/p_sCoolRate"] = SCR * LREF/TREF/UREF/3600;
  kernelInfo["defines/p_YLEN"]      = YLEN;

  coriolisKernel = udfBuildKernel(nrs, "coriolis");


  // Call interp_velocity w/ 0 particles to pre-compile the OCCA kernels
  dfloat *u_base[3] = {nullptr, nullptr, nullptr}, *x_base[3] = {nullptr, nullptr, nullptr};
  dlong u_stride[3] = {0, 0, 0},                  x_stride[3] = {0, 0, 0};
  if (USE_HOST_FINDPTS) {
    interp_velocity_host(u_base, u_stride, x_base, x_stride, 0, nrs);
  } else {
    interp_velocity(u_base, u_stride, x_base, x_stride, 0, nrs, IF_CHECK_ACCURACY);
  }
}

void UDF_Setup(nrs_t *nrs)
{
  udf.uEqnSource = &userf;

  int mpi_rank = platform_t::getInstance()->comm.mpiRank;
  int mpi_size = platform_t::getInstance()->comm.mpiCommSize;
  if (mpi_rank == 0) {
    std::cout << "Particle config: " << (mpi_size*LPART) << " particles (" << LPART << " local) "
                                     << "with " << (USE_HOST_FINDPTS ? "host" : "OCCA") << " findpts" << std::endl;
  }
}

void UDF_ExecuteStep(nrs_t *nrs, dfloat time, int tstep)
{
  if (USE_HOST_FINDPTS) {
    nrs->o_U.copyTo(nrs->U);
  }
  my_particle_generator(nrs, time, tstep);
}
