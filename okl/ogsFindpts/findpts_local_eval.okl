
#define CONST_N (p_NR == p_NS && (p_D == 2 || p_NR == p_NT))

#if CONST_N
#define INNER_SIZE p_D*p_NR
#define SUM_N INNER_SIZE
#else
#define INNER_SIZE (p_NR > p_NS ? (p_NR > p_NT ? p_NR : p_NT) : (p_NS > p_NT ? p_NS : p_NT))
#define SUM_N p_NR
#endif

@kernel void findpts_local_eval(
              dfloat * const out_base,   const dlong out_stride,
        const dlong  * const el_base,    const dlong el_stride,
        const dfloat * const r_base,     const dlong r_stride,
        const dlong pn,
        @restrict const dfloat * const in, const dlong in_stride,
        struct findpts_local_data *fd){

  for(dlong i=0;i<pn;++i;@outer){

#if CONST_N
    @shared dfloat wt[INNER_SIZE];
    @shared dfloat tmp[INNER_SIZE];
#else
    @shared dfloat wtr[p_NR];
    @shared dfloat wts[p_NS];
    @shared dfloat tmp[p_NR+p_NT+(p_D==3?p_NT:0)]
#if p_D == 3
    @shared dfloat wtt[p_NT];
#endif
#endif

    const dlong el = *CAT(dlong, el, i);
    const dfloat *in_el = in + el*in_stride;
    const dfloat * r = CAT(dfloat, r, i);

#if CONST_N
    for(dlong j=0;j<INNER_SIZE;++j;@inner){
      dlong dir = j/p_NR;
      dlong row = j%p_NR;
      if (dir < p_D) {
        lagrange_eval_1(             fd->fed.lag_data[dir], p_NR,    tmp+dir*p_NR, r[dir], row);
      }
    }
    for(dlong j=0;j<INNER_SIZE;++j;@inner){
      dlong dir = j/p_NR;
      dlong row = j%p_NR;
      if (dir < p_D) {
        lagrange_eval_2(wt+dir*p_NR, fd->fed.lag_data[dir], p_NR, 0, tmp+dir*p_NR,         row);
      }
    }
#else
    for(dlong j=0;j<INNER_SIZE;++j;@inner){
      lagrange_eval_1(     fd->fed.lag_data[0], p_NR,    tmp,           r[0], j);
      lagrange_eval_1(     fd->fed.lag_data[1], p_NS,    tmp+p_NR,      r[1], j);
#if p_D == 3
      lagrange_eval_1(     fd->fed.lag_data[2], p_NT,    tmp+p_NR+p_NS, r[2], j);
#endif
    }
    for(dlong j=0;j<INNER_SIZE;++j;@inner){
      lagrange_eval_2(wtr, fd->fed.lag_data[0], p_NR, 0, tmp,                 j);
      lagrange_eval_2(wts, fd->fed.lag_data[1], p_NS, 0, tmp+p_NR,            j);
#if p_D == 3
      lagrange_eval_2(wtt, fd->fed.lag_data[2], p_NT, 0, tmp+p_NR+p_NS,       j);
#endif
#endif
    }

    // out[i] = sum_j sum_k wts[j]*wtr[k]*in[j + k*nr]
  for(dlong jk=0;jk<INNER_SIZE;++jk;@inner){
    if(jk<SUM_N){
#if CONST_N
      const dlong j = jk%p_NR;
      const dlong kk = jk/p_NR;
      const dlong k_stride = p_D;
      const dfloat *wtr = wt+0*p_NR;
      const dfloat *wts = wt+1*p_NR;
#if p_D == 3
      const dfloat *wtt = wt+2*p_NR;
#endif
#else
      const dlong j = jk;
      const dlong kk = 0;
      const dlong k_stride = 1;
#endif

      dfloat sum_j = 0;
      const dfloat *in_el_j = in_el+j;

      for(dlong k=kk;k<p_NS;k+=k_stride){
  #if p_D == 3
        dfloat sum_k = 0;
        const dfloat *in_el_jk = in_el_j+k*p_NR;
        for(dlong l=0;l<p_NT;++l){
          sum_k += in_el_jk[l*p_NR*p_NS] * wtt[l];
        }
        sum_j += wts[k]*sum_k;
  #else
        sum_j += in_el_j[k*p_NR] * wts[k];
  #endif
      }
      tmp_0[j] = wtr[j]*sum_j;
    }
  }
// SUM_N is assumed to be at most 256
#if SUM_N>128
    for(dlong j=0;j<INNER_SIZE;++j;@inner){
      if(j<128&&j<SUM_N-128){
        tmp_0[j] += tmp_0[j+128];
      }
    }
#endif
#if SUM_N>64
    for(dlong j=0;j<INNER_SIZE;++j;@inner){
      if(j<64&&j<SUM_N-64){
        tmp_0[j] += tmp_0[j+64];
      }
    }
#endif
#if SUM_N>32
    for(dlong j=0;j<INNER_SIZE;++j;@inner){
      if(j<32&&j<SUM_N-32){
        tmp_0[j] += tmp_0[j+32];
      }
    }
#endif
#if SUM_N>16
    for(dlong j=0;j<INNER_SIZE;++j;@inner){
      if(j<16&&j<SUM_N-16){
        tmp_0[j] += tmp_0[j+16];
      }
    }
#endif
#if SUM_N>8
    for(dlong j=0;j<INNER_SIZE;++j;@inner){
      if(j<8&&j<SUM_N-8){
        tmp_0[j] += tmp_0[j+8];
      }
    }
#endif
#if SUM_N>4
    for(dlong j=0;j<INNER_SIZE;++j;@inner){
      if(j<4&&j<SUM_N-4){
        tmp_0[j] += tmp_0[j+4];
      }
    }
#endif
#if SUM_N>2
    for(dlong j=0;j<INNER_SIZE;++j;@inner){
      if(j<2&&j<SUM_N-2){
        tmp_0[j] += tmp_0[j+2];
      }
    }
#endif
    for(dlong j=0;j<INNER_SIZE;++j;@inner){
      if(j==0){
        dfloat * out = AT(dfloat, out, i);
        if(1<SUM_N){
          *out = tmp_0[0] + tmp_0[1];
        }else{
          *out = tmp_0[0];
        }
      }
    }
  }
}
