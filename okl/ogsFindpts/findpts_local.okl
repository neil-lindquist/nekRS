
#define CODE_INTERNAL  0
#define CODE_BORDER    1
#define CODE_NOT_FOUND 2

////// OBBOX //////

/* positive when possibly inside */
static dfloat obbox_axis_test(const struct obbox *const b,
                              const dfloat x[p_D])
{
  dfloat test = 1;
  for(dlong d=0;d<p_D;++d){
    dfloat b_d = (x[d]-b->x[d].min)*(b->x[0].max-x[0]);
    test = test<0 ? test : b_d;
  }
  return test;
}

/* positive when possibly inside */
static dfloat obbox_test(const struct obbox *const b, const dfloat x[p_D])
{
  const dfloat bxyz = obbox_axis_test(b,x);
  if(bxyz<0){
    return bxyz;
  }else {
    dfloat dxyz[p_D];
    for(dlong d=0;d<p_D;++d){
      dxyz[d] = x[d] - b->c0[d];
    }
    dfloat test = 1;
    for(dlong d=0;d<p_D;++d){
      dfloat rst = 0;
      for(dlong e=0;e<p_D;++e){
        rst += b->A[d*p_D+e]*dxyz[e];
      }
      dfloat brst = (rst+1)*(1-rst);
      test = test<0 ? test : brst;
    }
    return test;
  }
}


////// HASH //////


static dlong hash_index(const struct findpts_local_hash_data *p, const dfloat x[p_D])
{
  const dlong n = p->hash_n;
  dlong sum = 0;
  for(dlong d=p_D-1;d>=0;--d){
    sum *= n;
    dlong i = (dlong)floor((x[d]- p->bnd[d].min)*p->fac[d]);
    sum += i<0 ? 0 : (n-1<i ? n-1 : i);
  }
  return sum;
}

//// Linear algebra ////
/* A is row-major */
static void lin_solve_2(dfloat x[2], const dfloat A[4], const dfloat y[2])
{
  const dfloat idet = 1/(A[0]*A[3] - A[1]*A[2]);
  x[0] = idet*(A[3]*y[0] - A[1]*y[1]);
  x[1] = idet*(A[0]*y[1] - A[2]*y[0]);
}

/* A is row-major */
static void lin_solve_3(dfloat x[3], const dfloat A[9], const dfloat y[3])
{
  const dfloat a = A[4]*A[8]-A[5]*A[7],
               b = A[5]*A[6]-A[3]*A[8],
               c = A[3]*A[7]-A[4]*A[6],
            idet = 1/(A[0]*a+A[1]*b+A[2]*c);
  const dfloat
    inv0 = a,
    inv1 = A[2]*A[7]-A[1]*A[8],
    inv2 = A[1]*A[5]-A[2]*A[4],
    inv3 = b,
    inv4 = A[0]*A[8]-A[2]*A[6],
    inv5 = A[2]*A[3]-A[0]*A[5],
    inv6 = c,
    inv7 = A[1]*A[6]-A[0]*A[7],
    inv8 = A[0]*A[4]-A[1]*A[3];
  x[0] = idet*(inv0*y[0] + inv1*y[1] + inv2*y[2]);
  x[1] = idet*(inv3*y[0] + inv4*y[1] + inv5*y[2]);
  x[2] = idet*(inv6*y[0] + inv7*y[1] + inv8*y[2]);
}

static void lin_solve_sym_2(dfloat x[2], const dfloat A[3], const dfloat y[2])
{
  const dfloat idet = 1/(A[0]*A[2] - A[1]*A[1]);
  x[0] = idet*(A[2]*y[0] - A[1]*y[1]);
  x[1] = idet*(A[0]*y[1] - A[1]*y[0]);
}

static dfloat norm2(const dfloat x[p_D]) {
#if p_D==3
  return x[0]*x[0] + x[1]*x[1] + x[2]*x[2];
#else
  return x[0]*x[0] + x[1]*x[1];
#endif
}



/* the bit structure of flags is CTTSSRR
   the C bit --- 1<<6 --- is set when the point is converged
   RR is 0 = 00b if r is unconstrained,
         1 = 01b if r is constrained at -1
         2 = 10b if r is constrained at +1
   SS, TT are similarly for s and t constraints
   TT is ignored, but treated as set when p_D==2
*/

#define CONVERGED_FLAG (1u<<6)
#define FLAG_MASK 0x7fu

static dlong num_constrained(const dlong flags)
{
  const dlong y = flags | flags>>1;
  return (y&1u) + (y>>2 & 1u) + (((p_D==2)|y>>4) & 1u);
}

/* assumes x = 0, 1, or 2 */
static dlong plus_1_mod_3(const dlong x) { return ((x | x>>1)+1) & 3u; }
static dlong plus_2_mod_3(const dlong x)
{
  const dlong y = (x-1) & 3u;
  return y ^ (y>>1);
}
static dlong plus_1_mod_2(const dlong x) { return x^1u; }

/* assumes x = 1 << i, with i < 6, returns i+1 */
static dlong which_bit(const dlong x)
{
  const dlong y = x&7u;
  return (y-(y>>2)) | ((x-1)&4u) | (x>>4);
}

static dlong face_index(const dlong x) {
#if p_D==3
  return which_bit(x)-1;
#else
  return 2;
#endif
}

static dlong edge_index(const dlong x)
{
#if p_D==3
  const dlong y = ~((x>>1) | x);
  const dlong RTSR = ((x>>1)&1u) | ((x>>2)&2u) | ((x>>3)&4u) | ((x<<2)&8u);
  const dlong re = RTSR>>1;
  const dlong se = 4u | RTSR>>2;
  const dlong te = 8u | (RTSR&3u);
  return   ( (0u - ( y    &1u)) & re )
         | ( (0u - ((y>>2)&1u)) & se )
         | ( (0u - ((y>>4)&1u)) & te );
#else
  return which_bit(x)-1;
#endif
}

static dlong point_index(const dlong x)
{
  return ((x>>1)&1u) | ((x>>2)&2u) | ((x>>3)&4u);
}

#if p_D==3
// gets face info
// Must be called within an inner loop, with the final argument being the loop index
// workspace is a shared workspace
// side_init indicates the mode the workspace is set to
static findpts_el_gface get_face(
  const struct findpts_el_data *fd, const dfloat *elx[p_D], dlong fi,
  dfloat *workspace, dlong &side_init,
  dlong j)
{
  const dlong dn = fi>>1, d1 = plus_1_mod_3(dn), d2 = plus_2_mod_3(dn);
  const dlong n1 = fd->n[d1], n2=fd->n[d2], nn=fd->n[dn];
  const dlong n12 = n1*n2;
  const dlong side_n = fi&1;
  struct findpts_el_gface face;
  for(dlong d=0;d<p_D;++d){
    face.x[d]    = workspace +    d *n12;
    face.dxdn[d] = workspace + (3+d)*n12;
  }

  const dlong mask = 1u<<(fi/2);
  if((side_init & mask)==0) {
    const dlong elx_stride[3] = {1, p_NR, p_NR*p_NS};
    #define ELX(d, j, k, l) elx[d][j*elx_stride[d1]+k*elx_stride[d2]+l*elx_stride[dn]]
    if (j < n1) {
      for(dlong d=0;d<p_D;++d){
        for(dlong k=0;k<n2;++k){
          // copy first/last entries in normal direction
          face.x[d][j+k*n1] = ELX(d, j, k, side_n*(nn-1));

          // tensor product between elx and the derivative in the normal direction
          dfloat sum_l = 0;
          for(dlong l=0;l<nn;++l){
            sum_l += fd->wtend[dn][nn+l]*ELX(d, j, k, l);
          }
          face.dxdn[d][j+k*n1] = sum_l;
        }
      }
    }
    #undef ELX
    side_init = mask;
  }
  return face;
}
#endif

static findpts_el_gedge get_edge(
  const struct findpts_el_data *fd, const dfloat *elx[p_D], dlong ei,
  dfloat *workspace, dlong &side_init,
  dlong j)
{
  findpts_el_gedge edge;
#if p_D==3
  const dlong de = ei>>2, dn1 = plus_1_mod_3(de), dn2 = plus_2_mod_3(de);
  const dlong side_n1 = ei&1, side_n2 = (ei&2)>>1;
  const dlong nn2 = fd->n[dn2];
#else
  const dlong dn1 = ei>>1, de = plus_1_mod_2(dn1), dn2 = 2;
  const dlong side_n1 = ei&1, side_n2 = 0;
  const dlong nn2 = 1;
#endif
  const dlong n1 = fd->n[de], nn1 = fd->n[dn1];
  const dlong in1 = side_n1*(nn1-1), in2 = side_n2*(nn2-1);
  const dfloat *wt1 = fd->wtend[dn1]+side_n1*nn1*3;
#if p_D==3
  const dfloat *wt2 = fd->wtend[dn2]+side_n2*nn2*3;
#endif
  for(dlong d=0;d<p_D;++d){
    edge.x[d]      = workspace +      d *n1;
    edge.dxdn1[d]  = workspace + (p_D+d)*n1;
#if p_D==3
    edge.dxdn2[d]  = workspace + (  6+d)*n1;
    edge.d2xdn1[d] = workspace + (  7+d)*n1;
    edge.d2xdn2[d] = workspace + (  8+d)*n1;
#endif
  }

  const dlong mask = 8u<<(ei/2);
  if((side_init & mask)==0) {
    if (j < n1) {
      const dlong elx_stride[3] = {1, p_NR, p_NR*p_NS};
      #define ELX(d, j, k, l) elx[d][j*elx_stride[de]+k*elx_stride[dn1]+l*elx_stride[dn2]]
      for(dlong d=0;d<p_D;++d){
        // copy first/last entries in normal directions
        edge.x[d][j] = ELX(d, j, in1, in2);
#if p_D==3
        // tensor product between elx (w/ first/last entries in second direction)
        // and the derivatives in the first normal direction
        dfloat sums_k[2] = {0, 0};
        for(dlong k=0;k<nn1;++k){
          sums_k[0] += wt1[  nn1+k]*ELX(d, j, k,   in2);
          sums_k[1] += wt1[2*nn1+k]*ELX(d, j, k,   in2);
        }
        edge.dxdn1[d][j]  = sums_k[0];
        edge.d2xdn1[d][j] = sums_k[1];
        // tensor product between elx (w/ first/last entries in first direction)
        // and the derivatives in the second normal direction
        sums_k[0] = 0, sums_k[1] = 0;
        for(dlong k=0;k<nn2;++k){
          sums_k[0] += wt2[  nn2+k]*ELX(d, j, in1, k);
          sums_k[1] += wt2[2*nn2+k]*ELX(d, j, in1, k);
        }
        edge.dxdn2[d][j] = sums_k[0];
        edge.d2xdn2[d][j] = sums_k[1];
#else
        // tensor product between elx and the derivative in the normal direction
        dfloat sums_k = 0;
        for(dlong k=0;k<nn1;++k){
          sum_k += fd->wtend[dn][nn1+k]*ELX(d, j, k, 0);
        }
        edge.dxdn1[d][j] = sum_l;
#endif
      }
      #undef ELX
    }
    side_init = mask;
  }
  return edge;
}
static findpts_el_gpt get_pt(
  struct findpts_el_data *fd, const dfloat *elx[p_D], dlong pi)
{
  const dlong n1 = p_NR, n2 = p_NS, n3=p_NT;
#if p_D==3
  const dlong side_n1 = pi&1, side_n2 = (pi>>1)&1, side_n3 = (pi>>2)&1;
#else
  const dlong side_n1 = pi&1, side_n2 = (pi>>1)&1, side_n3=0;
#endif
  const dlong in1 = side_n1*(n1-1), in2 = side_n2*(n2-1), in3 = side_n3*(n3-1);
  const dlong hes_stride = (p_D+1)*p_D/2;
  findpts_el_gpt pt;

  #define ELX(d, j, k, l) elx[d][j+k*p_NR+l*p_NR*p_NS]
  for(dlong d=0;d<p_D;++d){
#if p_D==3
    pt.x[d] = ELX(d, side_n1*(n1-1), side_n2*(n2-1), side_n3*(n3-1));
#else
    pt.x[d] = ELX(d, side_n1*(n1-1), side_n2*(n2-1), 0);
#endif

    dfloat *wt1 = fd->wtend[0]+n1*(1+3*side_n1);
    dfloat *wt2 = fd->wtend[1]+n2*(1+3*side_n2);
#if p_D==3
    dfloat *wt3 = fd->wtend[2]+n3*(1+3*side_n3);
#endif

    for(dlong i=0;i<p_D;++i) pt.jac[p_D*d+i] = 0;
    for(dlong i=0;i<hes_stride;++i) pt.hes[hes_stride*d+i] = 0;

    for(dlong j=0;j<n1;++j){
      pt.jac[p_D*d+0]      += wt1[   j]*ELX(d, j, in2, in3);
      pt.hes[hes_stride*d] += wt1[n1+j]*ELX(d, j, in2, in3);
    }

    const dlong hes_off = hes_stride*d+hes_stride/2;
    for(dlong k=0;k<n2;++k){
      pt.jac[p_D*d+1] += wt2[   k]*ELX(d, in1, k, in3);
      pt.hes[hes_off] += wt2[n2+k]*ELX(d, in1, k, in3);
    }

#if p_D==3
    for(dlong l=0;l<n3;++l){
      pt.jac[p_D*d+2]        += wt3[   l]*ELX(d, in1, in2, l);
      pt.hes[hes_stride*d+5] += wt3[n3+l]*ELX(d, in1, in2, l);
    }

    for(dlong l=0;l<n3;++l){
      dfloat sum_k = 0, sum_j = 0;
      for(dlong k=0;k<n2;++k){
        sum_k += wt2[k]*ELX(d, in1, k, l);
      }
      for(dlong j=0;j<n1;++j){
        sum_j += wt1[j]*ELX(d, j, in2, l);
      }
      pt.hes[hes_stride*d+2] += wt3[l]*sum_j;
      pt.hes[hes_stride*d+4] += wt3[l]*sum_k;
    }
    for(dlong k=0;k<n2;++k){
      dfloat sum_j = 0;
      for(dlong j=0;j<n1;++j){
        sum_j += wt1[j]*ELX(d, j, k, in3);
      }
      pt.hes[hes_stride*d+1] += wt2[k]*sum_j;
    }
#endif
    #undef ELX
  }
  return pt;
}



/* check reduction in objective against prediction, and adjust
   trust region radius (p->tr) accordingly;
   may reject the prior step, returning 1; otherwise returns 0
   sets out->dist2, out->index, out->x, out->oldr in any event,
   leaving out->r, out->dr, out->flags to be set when returning 0 */
bool reject_prior_step_q(      findpts_el_pt *out,
                         const dfloat resid[p_D],
                         const findpts_el_pt *p,
                         const dfloat tol)
{
  const dfloat dist2 = norm2(resid);
  const dfloat decr = p->dist2 - dist2;
  const dfloat pred = p->dist2p;
  for(dlong d=0; d<p_D;++d){
    out->x[d] = p->x[d];
    out->oldr[d] = p->r[d];
  }
  out->dist2 = dist2;
  if(decr>= 0.01 * pred) {
    if(decr>= 0.9 * pred) {
      // very good iteration
      out->tr = p->tr*2;
    } else {
      // good iteration
      out->tr = p->tr;
    }
    return false;
  } else {
    /* reject step; note: the point will pass through this routine
       again, and we set things up here so it gets classed as a
       "very good iteration" --- this doubles the trust radius,
       which is why we divide by 4 below */
    dfloat v0 = fabs(p->r[0]-p->oldr[0]);
    dfloat v1 = fabs(p->r[1]-p->oldr[1]);
#if p_D==3
    dfloat v2 = fabs(p->r[2]-p->oldr[2]);
    out->tr = (v1>v2?(v0>v1?v0:v1):(v0>v2?v0:v2))/4;
#else
    out->tr = (v0>v1?v0:v1)/4;
#endif
    out->dist2=p->dist2;
    for(dlong d=0;d<p_D;++d) out->r[d]=p->oldr[d];
    out->flags=p->flags>>7;
    out->dist2p=-DBL_MAX;
    if(pred < dist2*tol) out->flags|=CONVERGED_FLAG;
    return true;
  }
}

#if p_D==3
/* minimize ||resid - jac * dr||_2, with |dr| <= tr, |r0+dr|<=1
   (exact solution of trust region problem) */
void newton_vol(struct findpts_el_pt *const out,
                       const dfloat jac[9], const dfloat resid[3],
                       const struct findpts_el_pt *const p, const dfloat tol)
{
  const dfloat tr = p->tr;
  dfloat bnd[6] = { -1,1, -1,1, -1,1 };
  dfloat r0[3];
  dfloat dr[3], fac;
  dlong d, mask, flags;
  r0[0]=p->r[0],r0[1]=p->r[1],r0[2]=p->r[2];

  mask = 0x3fu;
  for(d=0;d<3;++d) {
    if(r0[d]-tr>-1) bnd[2*d  ]=r0[d]-tr, mask^=1u<<(2*d);
    if(r0[d]+tr< 1) bnd[2*d+1]=r0[d]+tr, mask^=2u<<(2*d);
  }

  lin_solve_3(dr, jac,resid);

  fac = 1, flags = 0;
  for(d=0;d<3;++d) {
    dfloat nr = r0[d]+dr[d];
    if((nr-bnd[2*d])*(bnd[2*d+1]-nr)>=0) continue;
    if(nr<bnd[2*d]) {
      dfloat f = (bnd[2*d  ]-r0[d])/dr[d];
      if(f<fac) fac=f, flags = 1u<<(2*d);
    } else {
      dfloat f = (bnd[2*d+1]-r0[d])/dr[d];
      if(f<fac) fac=f, flags = 2u<<(2*d);
    }
  }

  if(flags==0) goto newton_vol_fin;

  for(d=0;d<3;++d) dr[d]*=fac;

  newton_vol_face: {
    const dlong fi = face_index(flags);
    const dlong dn = fi>>1, d1 = plus_1_mod_3(dn), d2 = plus_2_mod_3(dn);
    dfloat drc[2], fac=1;
    dlong new_flags=0;
    dfloat res[3], y[2], JtJ[3];
    res[0] = resid[0]-(jac[0]*dr[0]+jac[1]*dr[1]+jac[2]*dr[2]),
    res[1] = resid[1]-(jac[3]*dr[0]+jac[4]*dr[1]+jac[5]*dr[2]),
    res[2] = resid[2]-(jac[6]*dr[0]+jac[7]*dr[1]+jac[8]*dr[2]);
    /* y = J_u^T res */
    y[0] = jac[d1]*res[0]+jac[3+d1]*res[1]+jac[6+d1]*res[2],
    y[1] = jac[d2]*res[0]+jac[3+d2]*res[1]+jac[6+d2]*res[2];
    /* JtJ = J_u^T J_u */
    JtJ[0] = jac[  d1]*jac[  d1]
            +jac[3+d1]*jac[3+d1]
            +jac[6+d1]*jac[6+d1],
    JtJ[1] = jac[  d1]*jac[  d2]
            +jac[3+d1]*jac[3+d2]
            +jac[6+d1]*jac[6+d2],
    JtJ[2] = jac[  d2]*jac[  d2]
            +jac[3+d2]*jac[3+d2]
            +jac[6+d2]*jac[6+d2];
    lin_solve_sym_2(drc, JtJ,y);
    #define CHECK_CONSTRAINT(drcd,d3) { \
      const dfloat rz = r0[d3]+dr[d3], lb=bnd[2*d3],ub=bnd[2*d3+1]; \
      const dfloat delta=drcd, nr = r0[d3]+(dr[d3]+delta); \
      if((nr-lb)*(ub-nr)<0) { \
        if(nr<lb) { \
          dfloat f = (lb-rz)/delta; \
          if(f<fac) fac=f, new_flags = 1u<<(2*d3); \
        } else { \
          dfloat f = (ub-rz)/delta; \
          if(f<fac) fac=f, new_flags = 2u<<(2*d3); \
        } \
      } \
    }
    CHECK_CONSTRAINT(drc[0],d1); CHECK_CONSTRAINT(drc[1],d2);
    dr[d1] += fac*drc[0], dr[d2] += fac*drc[1];
    if(new_flags==0) goto newton_vol_fin;
    flags |= new_flags;
  }

  newton_vol_edge: {
    const dlong ei = edge_index(flags);
    const dlong de = ei>>2;
    dfloat fac = 1;
    dlong new_flags = 0;
    dfloat res[3],y,JtJ,drc;
    res[0] = resid[0]-(jac[0]*dr[0]+jac[1]*dr[1]+jac[2]*dr[2]),
    res[1] = resid[1]-(jac[3]*dr[0]+jac[4]*dr[1]+jac[5]*dr[2]),
    res[2] = resid[2]-(jac[6]*dr[0]+jac[7]*dr[1]+jac[8]*dr[2]);
    /* y = J_u^T res */
    y = jac[de]*res[0]+jac[3+de]*res[1]+jac[6+de]*res[2];
    /* JtJ = J_u^T J_u */
    JtJ = jac[  de]*jac[  de]
         +jac[3+de]*jac[3+de]
         +jac[6+de]*jac[6+de];
    drc = y/JtJ;
    CHECK_CONSTRAINT(drc,de);
    #undef CHECK_CONSTRAINT
    dr[de] += fac*drc;
    flags |= new_flags;
    goto newton_vol_relax;
  }

  /* check and possibly relax constraints */
  newton_vol_relax: {
    const dlong old_flags = flags;
    dfloat res[3], y[3];
    /* res := res_0 - J dr */
    res[0] = resid[0]-(jac[0]*dr[0]+jac[1]*dr[1]+jac[2]*dr[2]),
    res[1] = resid[1]-(jac[3]*dr[0]+jac[4]*dr[1]+jac[5]*dr[2]),
    res[2] = resid[2]-(jac[6]*dr[0]+jac[7]*dr[1]+jac[8]*dr[2]);
    /* y := J^T res */
    y[0] = jac[0]*res[0]+jac[3]*res[1]+jac[6]*res[2],
    y[1] = jac[1]*res[0]+jac[4]*res[1]+jac[7]*res[2],
    y[2] = jac[2]*res[0]+jac[5]*res[1]+jac[8]*res[2];
    for(dlong d=0;d<3;++d) {
      dlong f = flags>>(2*d) & 3u;
      if (f) {
        dr[d] = bnd[2*d+(f-1)] - r0[d];
        if(dr[d]*y[d]<0) flags &= ~(3u<<(2*d));
      }
    }
    if(flags==old_flags) goto newton_vol_fin;
    switch(num_constrained(flags)) {
      case 1: goto newton_vol_face;
      case 2: goto newton_vol_edge;
    }
  }

newton_vol_fin:
  flags &= mask;
  if(fabs(dr[0])+fabs(dr[1])+fabs(dr[2]) < tol) flags |= CONVERGED_FLAG;
  {
    const dfloat res0 = resid[0]-(jac[0]*dr[0]+jac[1]*dr[1]+jac[2]*dr[2]),
                 res1 = resid[1]-(jac[3]*dr[0]+jac[4]*dr[1]+jac[5]*dr[2]),
                 res2 = resid[2]-(jac[6]*dr[0]+jac[7]*dr[1]+jac[8]*dr[2]);
    out->dist2p=resid[0]*resid[0]+resid[1]*resid[1]+resid[2]*resid[2]
                -(res0*res0+res1*res1+res2*res2);
  }
  for(dlong d=0;d<p_D;++d){
    dlong f = flags>>(2*d)&3u;
    out->r[d] = f==0 ? r0[d]+dr[d] : (f==1 ? -1 : 1);
  }
  out->flags = flags | (p->flags<<7);
}
void newton_face(struct findpts_el_pt *const out,
                 const dfloat jac[9], const dfloat rhes[3],
                 const dfloat resid[3],
                 const dlong d1, const dlong d2, const dlong dn,
                 const dlong flags,
                 const struct findpts_el_pt *const p, const dfloat tol)
{
  const dfloat tr = p->tr;
  dfloat bnd[4];
  dfloat r[2], dr[2]={0,0};
  dlong mask, new_flags;
  dfloat v, tv; dlong i;
  dfloat A[3], y[2], r0[2];
  /* A = J^T J - resid_d H_d */
  A[0] = jac[  d1]*jac[  d1]
        +jac[3+d1]*jac[3+d1]
        +jac[6+d1]*jac[6+d1] - rhes[0],
  A[1] = jac[  d1]*jac[  d2]
        +jac[3+d1]*jac[3+d2]
        +jac[6+d1]*jac[6+d2] - rhes[1],
  A[2] = jac[  d2]*jac[  d2]
        +jac[3+d2]*jac[3+d2]
        +jac[6+d2]*jac[6+d2] - rhes[2];
  /* y = J^T r */
  y[0] = jac[  d1]*resid[0]
        +jac[3+d1]*resid[1]
        +jac[6+d1]*resid[2],
  y[1] = jac[  d2]*resid[0]
        +jac[3+d2]*resid[1]
        +jac[6+d2]*resid[2];
  r0[0] = p->r[d1], r0[1] = p->r[d2];

  new_flags=flags;
  mask=0x3fu;
  if(r0[0]-tr>-1) bnd[0]=-tr, mask^=1u;    else bnd[0]=-1-r0[0];
  if(r0[0]+tr< 1) bnd[1]= tr, mask^=2u;    else bnd[1]= 1-r0[0];
  if(r0[1]-tr>-1) bnd[2]=-tr, mask^=1u<<2; else bnd[2]=-1-r0[1];
  if(r0[1]+tr< 1) bnd[3]= tr, mask^=2u<<2; else bnd[3]= 1-r0[1];

  if(A[0]+A[2]<=0 || A[0]*A[2]<=A[1]*A[1]) goto newton_face_constrained;
  lin_solve_sym_2(dr, A,y);

  #define EVAL(r,s) -(y[0]*r+y[1]*s)+(r*A[0]*r+(2*r*A[1]+s*A[2])*s)/2
  if(   (dr[0]-bnd[0])*(bnd[1]-dr[0])>=0
     && (dr[1]-bnd[2])*(bnd[3]-dr[1])>=0) {
    r[0] = r0[0]+dr[0], r[1] = r0[1]+dr[1];
    v = EVAL(dr[0],dr[1]);
    goto newton_face_fin;
  }
newton_face_constrained:
  v  = EVAL(bnd[0],bnd[2]); i=1u|(1u<<2);
  tv = EVAL(bnd[1],bnd[2]); if(tv<v) v=tv, i=2u|(1u<<2);
  tv = EVAL(bnd[0],bnd[3]); if(tv<v) v=tv, i=1u|(2u<<2);
  tv = EVAL(bnd[1],bnd[3]); if(tv<v) v=tv, i=2u|(2u<<2);
  if(A[0]>0) {
    dfloat drc;
    drc = (y[0] - A[1]*bnd[2])/A[0];
    if((drc-bnd[0])*(bnd[1]-drc)>=0 && (tv=EVAL(drc,bnd[2]))<v)
      v=tv,i=1u<<2,dr[0]=drc;
    drc = (y[0] - A[1]*bnd[3])/A[0];
    if((drc-bnd[0])*(bnd[1]-drc)>=0 && (tv=EVAL(drc,bnd[3]))<v)
      v=tv,i=2u<<2,dr[0]=drc;
  }
  if(A[2]>0) {
    dfloat drc;
    drc = (y[1] - A[1]*bnd[0])/A[2];
    if((drc-bnd[2])*(bnd[3]-drc)>=0 && (tv=EVAL(bnd[0],drc))<v)
      v=tv,i=1u,dr[1]=drc;
    drc = (y[1] - A[1]*bnd[1])/A[2];
    if((drc-bnd[2])*(bnd[3]-drc)>=0 && (tv=EVAL(bnd[1],drc))<v)
      v=tv,i=2u,dr[1]=drc;
  }
  #undef EVAL

  {
    dlong dir[2]; dir[0] = d1; dir[1] = d2;
    for(dlong d=0;d<2;++d){
      const dlong f = i>>(2*d) & 3u;
      if(f==0) r[d]=r0[d]+dr[d];
      else {
        if((f&(mask>>(2*d)))==0) r[d]=r0[d]+(f==1?-tr:tr);
        else                     r[d]=(f==1?-1:1), new_flags |= f<<(2*dir[d]);
      }
    }
  }
newton_face_fin:
  out->dist2p = -2*v;
  dr[0]=r[0]-p->r[d1];
  dr[1]=r[1]-p->r[d2];
  if(fabs(dr[0])+fabs(dr[1]) < tol) new_flags |= CONVERGED_FLAG;
  out->r[dn]=p->r[dn], out->r[d1]=r[0],out->r[d2]=r[1];
  out->flags = new_flags | (p->flags<<7);
}

static void newton_edge(struct findpts_el_pt *const out,
  const dfloat jac[9], const dfloat rhes, const dfloat resid[3],
  const dlong de, const dlong dn1, const dlong dn2,
  dlong flags,
  const struct findpts_el_pt *const p, const dfloat tol)
{
  const dfloat tr = p->tr;
  /* A = J^T J - resid_d H_d */
  const dfloat A = jac[  de]*jac[  de]
                  +jac[3+de]*jac[3+de]
                  +jac[6+de]*jac[6+de] - rhes;
  /* y = J^T r */
  const dfloat y = jac[  de]*resid[0]
                  +jac[3+de]*resid[1]
                  +jac[6+de]*resid[2];

  const dfloat oldr = p->r[de];
  dfloat dr,nr,tdr,tnr;
  dfloat v,tv; dlong new_flags=0, tnew_flags=0;

  #define EVAL(dr) (dr*A-2*y)*dr

  /* if A is not SPD, quadratic model has no minimum */
  if(A>0) {
    dr = y/A, nr = oldr+dr;
    if(fabs(dr)<tr && fabs(nr)<1) { v=EVAL(dr); goto newton_edge_fin; }
  }

  if(( nr=oldr-tr)>-1)  dr=-tr;
  else                  nr=-1,  dr=-1-oldr,  new_flags = flags | 1u<<(2*de);
  v =EVAL( dr);

  if((tnr=oldr+tr)< 1) tdr=tr;
  else                 tnr= 1, tdr= 1-oldr, tnew_flags = flags | 2u<<(2*de);
  tv=EVAL(tdr);

  if(tv<v) nr=tnr, dr=tdr, v=tv, new_flags=tnew_flags;

newton_edge_fin:
  /* check convergence */
  if(fabs(dr) < tol) new_flags |= CONVERGED_FLAG;
  out->r[de]=nr;
  out->r[dn1]=p->r[dn1];
  out->r[dn2]=p->r[dn2];
  out->dist2p = -v;
  out->flags = flags | new_flags | (p->flags<<7);
}

#else

void newton_area(struct findpts_el_pt *const out,
                 const dfloat jac[4], const dfloat resid[2],
                 const struct findpts_el_pt *const p, const dfloat tol)
{
  const dfloat tr = p->tr;
  dfloat bnd[4] = { -1,1, -1,1 };
  dfloat r0[2];
  dfloat dr[2], fac;
  dlong d, mask, flags;

  r0[0] = p->r[0], r0[1] = p->r[1];

  mask = 0xfu;
  for(d=0;d<2;++d) {
    if(r0[d]-tr>-1) bnd[2*d  ]=r0[d]-tr, mask^=1u<<(2*d);
    if(r0[d]+tr< 1) bnd[2*d+1]=r0[d]+tr, mask^=2u<<(2*d);
  }

  lin_solve_2(dr, jac,resid);

  fac = 1, flags = 0;
  for(d=0;d<2;++d) {
    dfloat nr = r0[d]+dr[d];
    if((nr-bnd[2*d])*(bnd[2*d+1]-nr)>=0) continue;
    if(nr<bnd[2*d]) {
      dfloat f = (bnd[2*d  ]-r0[d])/dr[d];
      if(f<fac) fac=f, flags = 1u<<(2*d);
    } else {
      dfloat f = (bnd[2*d+1]-r0[d])/dr[d];
      if(f<fac) fac=f, flags = 2u<<(2*d);
    }
  }

  if(flags==0) goto newton_area_fin;

  for(d=0;d<2;++d) dr[d]*=fac;

  newton_area_edge: {
    const dlong ei = edge_index(flags);
    const dlong dn = ei>>1, de = plus_1_mod_2(dn);
    const dfloat res0 = resid[0]-(jac[0]*dr[0]+jac[1]*dr[1]),
                 res1 = resid[1]-(jac[2]*dr[0]+jac[3]*dr[1]);
    /* y = J_u^T res */
    const dfloat y = jac[de]*res0+jac[2+de]*res1;
    /* JtJ = J_u^T J_u */
    const dfloat JtJ = jac[  de]*jac[  de]
                      +jac[2+de]*jac[2+de];
    const dfloat drc = y/JtJ;
    dfloat fac = 1;
    dlong new_flags = 0;
    {
      const dfloat rz = r0[de]+dr[de], lb=bnd[2*de],ub=bnd[2*de+1];
      const dfloat nr = r0[de]+(dr[de]+drc);
      if((nr-lb)*(ub-nr)<0) {
        if(nr<lb) {
          dfloat f = (lb-rz)/drc;
          if(f<fac) fac=f, new_flags = 1u<<(2*de);
        } else {
          dfloat f = (ub-rz)/drc;
          if(f<fac) fac=f, new_flags = 2u<<(2*de);
        }
      }
    }
    dr[de] += fac*drc;
    flags |= new_flags;
    goto newton_area_relax;
  }

  /* check and possibly relax constraints */
  newton_area_relax: {
    const dlong old_flags = flags;
    /* res := res_0 - J dr */
    const dfloat res0 = resid[0]-(jac[0]*dr[0]+jac[1]*dr[1]),
                 res1 = resid[1]-(jac[2]*dr[0]+jac[3]*dr[1]);
    /* y := J^T res */
    dfloat y[2]; y[0] = jac[0]*res0+jac[2]*res1,
                 y[1] = jac[1]*res0+jac[3]*res1;
    for(dlong d=0;d<p_D;++d){
      dlong f = flags>>(2*d) & 3u;
      if(f) dr[d] = bnd[2*d+(f-1)] - r0[d];
    }
    for(d=0;d<2;++d) {
      dlong c = flags>>(2*d) & 3u;
      if(c==0) continue;
      else if(dr[d]*y[d]<0) flags &= ~(3u<<(2*d));
        printf("FAIL! c=%u, dr[d]=%g\n",c,dr[d]);
    }
    if(flags==old_flags) goto newton_area_fin;
    switch(num_constrained(flags)) {
      case 1: goto newton_area_edge;
    }
  }

newton_area_fin:
  flags &= mask;
  if(fabs(dr[0])+fabs(dr[1]) < tol) flags |= CONVERGED_FLAG;
  {
    const dfloat res0 = resid[0]-(jac[0]*dr[0]+jac[1]*dr[1]),
                 res1 = resid[1]-(jac[2]*dr[0]+jac[3]*dr[1]);
    out->dist2p=resid[0]*resid[0]+resid[1]*resid[1]
                -(res0*res0+res1*res1);
  }
  for(dlong d=0;d<p_D;++d){
    dlong f = flags>>(2*d) & 3u;
    out->r[d] = f==0 ? r0[d]+dr[d] : ( f==1 ? -1 : 1 );
  }
  out->flags = flags | (p->flags<<7);
}

static void newton_edge(struct findpts_el_pt *const out,
  const dfloat jac[4], const dfloat rhes, const dfloat resid[2],
  const dlong de, const dlong dn,
  dlong flags,
  const struct findpts_el_pt *const p, const dfloat tol)
{
  const dfloat tr = p->tr;
  /* A = J^T J - resid_d H_d */
  const dfloat A = jac[  de]*jac[  de]
                  +jac[2+de]*jac[2+de] - rhes;
  /* y = J^T r */
  const dfloat y = jac[  de]*resid[0]
                  +jac[2+de]*resid[1];

  const dfloat oldr = p->r[de];
  dfloat dr,nr,tdr,tnr;
  dfloat v,tv; dlong new_flags=0, tnew_flags=0;

  #define EVAL(dr) (dr*A-2*y)*dr

  /* if A is not SPD, quadratic model has no minimum */
  if(A>0) {
    dr = y/A, nr = oldr+dr;
    if(fabs(dr)<tr && fabs(nr)<1) { v=EVAL(dr); goto newton_edge_fin; }
  }

  if(( nr=oldr-tr)>-1)  dr=-tr;
  else                  nr=-1,  dr=-1-oldr,  new_flags = flags | 1u<<(2*de);
  v =EVAL( dr);

  if((tnr=oldr+tr)< 1) tdr=tr;
  else                 tnr= 1, tdr= 1-oldr, tnew_flags = flags | 2u<<(2*de);
  tv=EVAL(tdr);

  if(tv<v) nr=tnr, dr=tdr, v=tv, new_flags=tnew_flags;

newton_edge_fin:
  /* check convergence */
  if(fabs(dr) < tol) new_flags |= CONVERGED_FLAG;
  out->r[de]=nr;
  out->r[dn]=p->r[dn];
  out->dist2p = -v;
  out->flags = flags | new_flags | (p->flags<<7);
}
#endif

void seed_j(const dfloat *elx[p_D],
            const dfloat  x[p_D],
                  dfloat *z[p_D],
                  dfloat  dist2[p_NR],
                  dfloat *r[p_D],
            const int j)
{
  if (j >= p_NR) return;

  dist2[j] = DBL_MAX;

  dfloat zr = z[0][j];
  for (dlong l = 0; l < p_NT; ++l) {
#if p_D == 3
    const dfloat zt = z[2][l];
#endif
    for (dlong k = 0; k < p_NS; ++k) {
      dfloat zs = z[1][k];

      dlong jkl = j + k*p_NR + l*p_NR*p_NS;
      dfloat dx[p_D];
      for(dlong d=0;d<p_D;++d) dx[d] = x[d]-elx[d][jkl];
      const dfloat dist2_jkl = norm2(dx);
      ++jkl;
      if (dist2[j] > dist2_jkl) {
        dist2[j] = dist2_jkl;
        r[0][j] = zr;
        r[1][j] = zs;
#if p_D == 3
        r[2][j] = zt;
#endif
      }
    }
  }
}

#if p_D==3
dfloat tensor_ig3_j(      dfloat *g_partials,
                    const dfloat *Jr,
                    const dfloat *Dr,
                    const dfloat *Js,
                    const dfloat *Ds,
                    const dfloat *Jt,
                    const dfloat *Dt,
                    const dfloat *u,
                    const dlong j)
{
  dfloat sum;
  if (j < p_NR) {
    dfloat uJtJs = 0.0;
    dfloat uDtJs = 0.0;
    dfloat uJtDs = 0.0;
    for(dlong k=0; k<p_NS;++k) {
      dfloat uJt = 0.0;
      dfloat uDt = 0.0;
      for(dlong l=0; l<p_NT;++l) {
        uJt += u[j+k*p_NR+l*p_NR*p_NS]*Jt[l];
        uDt += u[j+k*p_NR+l*p_NR*p_NS]*Dt[l];
      }

      uJtJs += uJt*Js[k];
      uJtDs += uJt*Ds[k];
      uDtJs += uDt*Js[k];
    }

    sum           = uJtJs*Jr[j];
    g_partials[0] = uJtJs*Dr[j];
    g_partials[1] = uJtDs*Jr[j];
    g_partials[2] = uDtJs*Jr[j];
  }
  return sum;
}
#endif

@kernel void ogs_findpts_local(
        dlong  *const  code_base     , const dlong  code_stride     ,
        dlong  *const    el_base     , const dlong    el_stride     ,
        dfloat *const     r_base     , const dlong     r_stride     ,
        dfloat *const dist2_base     , const dlong dist2_stride     ,
  const dfloat *const     x_base[p_D], const dlong     x_stride[p_D],
  const dlong npt, struct findpts_local_data *fd)
{
  #define MAX_CONST(a,b) ((a>b)?(a):(b))
  #define INNER_SIZE (MAX_CONST(p_NR,                            \
                      MAX_CONST(p_NS,                            \
                      MAX_CONST(p_NT,                            \
                               (2*p_D-1)*p_D))))  //findpt_edge

  for (dlong i = 0; i < npt; ++i; @outer) {
    // OCCA can't used constexpr's for shared variable sizes
    #define MAX_N (MAX_CONST(p_NR, MAX_CONST(p_NS, p_NT)))
    // workspace = max(p_NR*(p_D+1),                               // seed
    //                 (p_NR+1)*(p_D+p_D*p_D)+2*(p_NR+p_NS+p_NT),  // findpt_vol
    //                 (2*p_D+p_D*p_D)*(MAX_N+1)+p_D*2*MAX_N,      // findpt_area / findpt_face
    //                 p_D+2*p_D*p_D+(p_D+1)*(2*p_D-1)+p_D*MAX_N)) // findpt_edge
    @shared dfloat r_workspace[MAX_CONST(4, MAX_N+1)*(p_D*p_D+2*p_D) + p_D*2*MAX_N];
    @shared findpts_el_pt el_pts[2];

#if p_D==3
    #define CONSTRAINT_SIZE MAX_CONST(MAX_N*MAX_N*6, MAX_N*p_D*3)
#else
    #define CONSTRAINT_SIZE MAX_N*p_D*2;
#endif
    @shared dfloat constraint_workspace[CONSTRAINT_SIZE];
    @exclusive dlong constraint_init;

    // OCCA has limits on access to shared variables outside inner loops
    dfloat *r_workspace_ptr;
    findpts_el_pt *fpt, *tmp;
    for(dlong j=0;j<INNER_SIZE;++j;@inner){
      r_workspace_ptr = r_workspace;
      fpt = el_pts+0;
      tmp = el_pts+1;
    }

    const dlong n[3] = {p_NR, p_NS, p_NT};

    dfloat x_i[p_D];
    for(dlong d=0;d<p_D;++d){
        x_i[d] = (*CATD(dfloat, x, i, d));
    }
    dlong  *code_i  = AT(dlong,  code,  i);
    dlong  *el_i    = AT(dlong,  el,    i);
    dfloat *r_i     = AT(dfloat, r,     i);
    dfloat *dist2_i = AT(dfloat, dist2, i);

    //// map_points_to_els ////
    const dlong hi = hash_index(&fd->hd,x_i);
    const dlong       *elp = fd->hd.offset + fd->hd.offset[hi  ],
                *const ele = fd->hd.offset + fd->hd.offset[hi+1];
    *code_i = CODE_NOT_FOUND;

    for(; elp!=ele; ++elp) {
      const dlong el = *elp;
      if(obbox_test(&fd->obb[el],x_i)>=0) {
        //// findpts_local ////
        {
          const dfloat *elx[p_D];
          for(dlong d=0;d<p_D;++d) elx[d]=fd->elx[d]+el*fd->ntot;

          //// findpts_el ////
          {
            for(dlong j = 0; j<INNER_SIZE;++j;@inner){
              if(j==0){
                fpt->dist2 = DBL_MAX; fpt->dist2p=0; fpt->tr=1;
              }
              if(j<p_D) fpt->x[j]=x_i[j];
              constraint_init = 0;
            }
            //// seed ////
            {
              dfloat *dist2_temp = r_workspace_ptr;
              dfloat *r_temp[p_D]; for(dlong d=0;d<p_D;++d) r_temp[d]=dist2_temp+(1+d)*p_NR;
              for(dlong j=0;j<INNER_SIZE;++j;@inner){
                seed_j(elx, x_i, fd->fed.z, dist2_temp, r_temp, j);
              }
              // TODO switch to binary reduction
              for(dlong j=0;j<INNER_SIZE;++j;@inner){
                if (j == 0) {
                  fpt->dist2 = DBL_MAX;
                  for(dlong j=0;j<p_NR;++j) {
                    if(dist2_temp[j]<fpt->dist2){
                      fpt->dist2 = dist2_temp[j];
                      for(dlong d=0;d<p_D;++d) fpt->r[d] = r_temp[d][j];
                    }
                  }
                }
              }
            }

            for(dlong j = 0; j<INNER_SIZE;++j;@inner){
              if(j==0){
                tmp->dist2=DBL_MAX; tmp->dist2p=0; tmp->tr=1; tmp->flags=0;
                for(dlong d=0;d<p_D;++d){tmp->x[d]=fpt->x[d]; tmp->r[d]=fpt->r[d];}
              }
            }

            for(dlong step=0;step<50;++step) {
              switch (num_constrained(tmp->flags & FLAG_MASK)) {
                case 0:{ // findpt_vol
// need 3 dimensions to have a volume
#if p_D==3
                  dfloat *wtr = r_workspace_ptr;
                  dfloat *wts = wtr + 2*p_NR;
                  dfloat *wtt = wts + 2*p_NS;

                  dfloat *resid = wtt+2*p_NT;
                  dfloat *jac   = resid + 3;
                  dfloat *resid_temp = jac + 9;
                  dfloat *jac_temp   = resid_temp + 3*p_NR;

                  for(dlong j=0;j<INNER_SIZE;++j;@inner){
                    // need to compute 1st derivatives
                    lagrange_eval(wtr, fd->fed.lag_data[0], p_NR, 1, tmp->r[0], j);
                    lagrange_eval(wts, fd->fed.lag_data[1], p_NS, 1, tmp->r[1], j);
                    lagrange_eval(wtt, fd->fed.lag_data[2], p_NT, 1, tmp->r[2], j);
                  }    
                  for (dlong j = 0; j < INNER_SIZE; ++j;@inner) {
                    if(j<p_NR){
                      for(dlong d=0;d<3;++d){
                        resid_temp[d+j*3] = tensor_ig3_j(jac_temp+3*d+9*j,
                                                         wtr, wtr+p_NR,
                                                         wts, wts+p_NS,
                                                         wtt, wtt+p_NT,
                                                         elx[d],
                                                         j);
                      }
                    }
                  }
                  // TODO consider binary reduction
                  for(dlong l=0;l<INNER_SIZE;++l;@inner){
                    if(l<3){
                      resid[l] = tmp->x[l];
                      for(dlong j=0;j<p_NR;++j) {
                        resid[l] -= resid_temp[l+j*3];
                      }
                    }
                    if(l<9){
                      jac[l] = 0;
                      for(dlong j=0;j<p_NR;++j) {
                        jac[l] += jac_temp[l+j*9];
                      }
                    }
                  }
                  if(reject_prior_step_q(fpt, resid, tmp, fd->tol)) break;
                  newton_vol(fpt, jac, resid, tmp, fd->tol);
#endif
                  break;
                }
                case 1:{ // findpt_face / findpt_area
                  const dlong fi = face_index(tmp->flags & FLAG_MASK);
                  const dlong dn = fi>>1;
                  const dlong d1 = plus_1_mod_3(dn), d2 = plus_2_mod_3(dn);
                  const dlong n1 = n[d1], n2 = n[d2];
                  const dlong der = p_D-1; // 2nd derivatives for p_D=3, 1st for p_D=2

                  dfloat *wt1 = r_workspace_ptr;
                  dfloat *wt2 = wt1 + (der+1)*n1;
                  dfloat *resid = wt2 + (der+1)*n2;
                  dfloat *jac   = resid + p_D;
                  dfloat *resid_temp = jac + p_D*p_D;
                  dfloat *jac_temp   = resid_temp + p_D*n1;
#if p_D==3
                  dfloat *hes      = jac_temp + p_D*p_D*n1;
                  dfloat *hes_temp = hes + p_D;
#endif
                  for(dlong j=0;j<INNER_SIZE;++j;@inner){
                    // need to compute 1st derivatives
                    lagrange_eval(wt1, fd->fed.lag_data[d1], n1, der, tmp->r[d1], j);
                    lagrange_eval(wt2, fd->fed.lag_data[d2], n2, der, tmp->r[d2], j);
                  }
                  dfloat *J1 = wt1, *D1 = wt1+n1;
                  dfloat *J2 = wt2, *D2 = wt2+n2;
#if p_D==3
                  dfloat *DD1 = D1+n1, *DD2 = D2+n2;
                  struct findpts_el_gface face;
                  for(dlong j=0;j<INNER_SIZE;++j;@inner){
                    face = get_face(&fd->fed,elx,fi,constraint_workspace,constraint_init,j);
                  }
#endif
                  for(dlong j=0;j<INNER_SIZE;++j;@inner){
                    if (j < n1) {
                      for(dlong d=0;d<p_D;++d) {
#if p_D==3
                        const dfloat *u = face.x[d];
                        const dfloat *du = face.dxdn[d];
#else
                        const dfloat *u = elx[d];
#endif
                        dfloat sums_k[4] = {0.0, 0.0, 0.0, 0.0};
                        for(dlong k=0; k<n2;++k) {
                          sums_k[0] +=  u[j+k*n1]*J2[k];
                          sums_k[1] +=  u[j+k*n1]*D2[k];
#if p_D==3
                          sums_k[2] +=  u[j+k*n1]*DD2[k];
                          sums_k[3] += du[j+k*n1]*J2[k];
#endif
                        }

                        resid_temp[p_D*j+d] = sums_k[0]*J1[j];
                        jac_temp[p_D*p_D*j+p_D*d+d1] = sums_k[0]*D1[j];
                        jac_temp[p_D*p_D*j+p_D*d+d2] = sums_k[1]*J1[j];
#if p_D==3
                        jac_temp[p_D*p_D*j+p_D*d+dn] = sums_k[3]*J1[j];
                        hes_temp[p_D*j  ]   = sums_k[0]*DD1[j];
                        hes_temp[p_D*j+1]   = sums_k[1]*D1[j];
                        hes_temp[p_D*j+2]   = sums_k[2]*J1[j];
#endif
                      }
                    }
                  }
                  // TODO consider binary reduction
                  for(dlong l=0;l<INNER_SIZE;++l;@inner){
                    if(l<p_D){
                      resid[l] = fpt->x[l];
                      for(dlong j=0;j<n1;++j) resid[l] -= resid_temp[l+j*p_D];
                    }
                    if(l<p_D*p_D){
                      jac[l] = 0;
                      for(dlong j=0;j<n1;++j) jac[l] += jac_temp[l+j*p_D*p_D];
                    }
#if p_D==3
                    if(l<p_D){
                      hes[l] = 0;
                      for(dlong j=0;j<n1;++j) hes[l] += hes_temp[l+3*j];
                      hes[l] *= resid[l];
                    }
#endif
                  }
                  if(reject_prior_step_q(fpt, resid, tmp, fd->tol)) break;

#if p_D==3
                  const dfloat steep = resid[0] * jac[  dn]
                                      +resid[1] * jac[3+dn]
                                      +resid[2] * jac[6+dn];
                  if(steep * tmp->r[dn] < 0){ /* relax constraint */
                    newton_vol(fpt, jac, resid, tmp, fd->tol);
                  }else{
                    newton_face(fpt, jac, hes, resid, d1,d2,dn,
                                tmp->flags&FLAG_MASK, tmp, fd->tol);
                  }
#else
                  newton_area(fpt, jac, resid, tmp, fd->tol);
#endif
                  break;
                }
                case 2:{ // findpt_edge
                  const dlong ei = edge_index(tmp->flags & FLAG_MASK);
#if p_D==3
                  const dlong de = ei>>2, dn1 = plus_1_mod_3(de), dn2 = plus_2_mod_3(de);
#else
                  const dlong dn1 = ei>>1, dne = plus_1_mod_2(dn1), dn2 = -1;
#endif
                  const dlong n1 = n[de];
                  dlong d_j[3]; d_j[0] = de; d_j[1] = dn1; d_j[2] = dn2;
                  const dlong hes_count = 2*p_D-1; // p_D=3 ? 5 : 1;

                  dfloat *wt     = r_workspace_ptr;
                  dfloat *resid = wt    + 3*n1;
                  dfloat *jac   = resid + p_D;
                  dfloat *hes_T = jac   + p_D*p_D;
                  dfloat *hes   = hes_T + hes_count*p_D;
                  struct findpts_el_gedge edge;
                  for(dlong j=0;j<INNER_SIZE;++j;@inner){
                    edge = get_edge(&fd->fed,elx,ei,constraint_workspace,constraint_init,j);
                  }
#if p_D==3
                  // TODO consider optimizing this using the internal structure of findpts_el_gedge
                  const dfloat* const* e_x[p_D+3] = {edge.x, edge.x, edge.dxdn1, edge.dxdn2, edge.d2xdn1, edge.d2xdn2};
#else
                  const dfloat* const* e_x[p_D+1] = {edge.x, edge.x, edge.dxdn1};
#endif
                  for(dlong j=0;j<INNER_SIZE;++j;@inner){
                    lagrange_eval(wt, fd->fed.lag_data[de], n1, 2, tmp->r[de], j);
                  }

                  for(dlong j=0;j<INNER_SIZE;++j;@inner){
                    const  dlong d = j%p_D;
                    const dlong row = j/p_D;
                    if (j < (p_D+1)*p_D) {
                      // resid and jac_T
                      // [0, 1, 0, 0]
                      dfloat *wt_j = wt + (row==1?n1:0);
                      const dfloat *x = e_x[row][d];
                      dfloat sum = 0.0;
                      for(dlong k=0;k<n1;++k){
                        // resid+p_D == jac_T
                        sum += wt_j[k]*x[k];
                      }
                      if(j<p_D){
                        resid[j] = tmp->x[j] - sum;
                      }else{
                        jac[d*p_D + d_j[row-1]] = sum;
                      }
                    }
                    if (j < hes_count*p_D) {
                      // Hes_T is transposed version (i.e. in col major)

                      // n1*[2, 1, 1, 0, 0]
                      // j==1 => wt_j = wt+n1
                      dfloat *wt_j = wt + n1*(2-(row+1)/2);
                      const dfloat *x = e_x[row+1][d];
                      hes_T[j] = 0.0;
                      for(dlong k=0;k<n1;++k){
                        hes_T[j] += wt_j[k]*x[k];
                      }
                    }
                  }
                  for(dlong j=0;j<INNER_SIZE;++j;@inner){
                    if(j < hes_count){
                      hes[j] = 0.0;
                      for(dlong d=0;d<p_D;++d){
                        hes[j] += resid[d] * hes_T[j*3 + d];
                      }
                    }
                  }
                  /* check prior step */
                  if(reject_prior_step_q(fpt,resid,tmp,fd->tol)) break;

                  /* check constraint */
                  dfloat steep[p_D-1];
                  for(dlong k=0;k<p_D-1;++k){
                    dlong dn = d_j[k+1];
                    steep[k]=0;
                    for(dlong d=0;d<p_D;++d){
                      steep[k] += jac[dn+d*p_D]*resid[d];
                    }
                    steep[k] *= tmp->r[dn];
                  }
#if p_D==3
                  if(steep[0]<0) {
                    if(steep[1]<0) {
                      newton_vol(fpt, jac,resid, tmp, fd->tol);
                    } else {
                      dfloat rh[3]; rh[0]=hes[0], rh[1]=hes[1], rh[2]=hes[3];
                      newton_face(fpt, jac,rh,resid, de,dn1,dn2,
                                  tmp->flags & (3u<<(dn2*2)), tmp, fd->tol);
                    }
                  } else {
                    if(steep[1]<0) {
                      dfloat rh[3]; rh[0]=hes[4], rh[1]=hes[2], rh[2]=hes[0];
                      newton_face(fpt, jac,rh,resid, dn2,de,dn1,
                                  tmp->flags & (3u<<(dn1*2)), tmp, fd->tol);
                    } else {
                      newton_edge(fpt, jac,hes[0],resid, de,dn1,dn2,
                                  tmp->flags & FLAG_MASK, tmp, fd->tol);
                    }
                  }
#else
                  if(steep[0]) { /* relax constraint */
                    newton_area(fpt, jac, resid, tmp, fd->tol);
                  } else {
                    newton_edge(fpt, jac, hes[0], resid, de,dn1,
                                tmp->flags & FLAG_MASK, tmp, fd->tol);
                  }
#endif
                  break;
                }
                case 3:{ // findpts_pt
                  const dlong pi = point_index(tmp->flags & FLAG_MASK);
                  const struct findpts_el_gpt gpt = get_pt(&fd->fed,elx,pi);
                  const dfloat *const pt_x = gpt.x, *const jac = gpt.jac, *const hes = gpt.hes;

                  dfloat resid[p_D], steep[p_D];
                  for(dlong d=0;d<p_D;++d){
                    resid[d] = fpt->x[d]-pt_x[d];
                  }
                  if(reject_prior_step_q(fpt,resid,tmp,fd->tol)) break;
                  for(dlong d=0;d<p_D;++d){
                    steep[d]=0;
                    for(dlong e=0;d<p_D;++d){
                      steep[d] += jac[d+e*p_D]*resid[d];
                    }
                    steep[d] *= tmp->r[d];
                  }
#if p_D==3
                  dlong de, dn1, dn2, d1, d2, dn, hi0, hi1, hi2;
                  if(steep[0]<0) {
                    if(steep[1]<0) {
                      if(steep[2]<0){
                        goto findpt_pt_vol;
                      }else {
                        d1=0,d2=1,dn=2, hi0=0,hi1=1,hi2=3;
                        goto findpt_pt_face;
                      }
                    }else {
                      if(steep[2]<0) {
                        d1=2,d2=0,dn=1, hi0=5,hi1=2,hi2=0;
                        goto findpt_pt_face;
                      }else {
                        de=0,dn1=1,dn2=2, hi0=0;
                        goto findpt_pt_edge;
                      }
                    }
                  }else {
                    if(steep[1]<0) {
                      if(steep[2]<0) {
                        d1=1,d2=2,dn=0, hi0=3,hi1=4,hi2=5;
                        goto findpt_pt_face;
                      }else {
                        de=1,dn1=2,dn2=0, hi0=3;
                        goto findpt_pt_edge;
                      }
                    }else{
                      if(steep[2]<0) {
                        de=2,dn1=0,dn2=1, hi0=5;
                        goto findpt_pt_edge;
                      } else {
                        fpt->r[0]=tmp->r[0],fpt->r[1]=tmp->r[1],fpt->r[2]=tmp->r[2];
                        fpt->dist2p=0;
                        fpt->flags = tmp->flags | CONVERGED_FLAG;
                        break;
                      }
                    }
                  }
                  findpt_pt_vol:
                    newton_vol(fpt, jac,resid, tmp, fd->tol);
                    break;
                  findpt_pt_face: {
                    dfloat rh[3];
                    rh[0] = resid[0]*hes[hi0]+resid[1]*hes[6+hi0]+resid[2]*hes[12+hi0],
                    rh[1] = resid[0]*hes[hi1]+resid[1]*hes[6+hi1]+resid[2]*hes[12+hi1],
                    rh[2] = resid[0]*hes[hi2]+resid[1]*hes[6+hi2]+resid[2]*hes[12+hi2];
                    newton_face(fpt, jac,rh,resid, d1,d2,dn,
                                (tmp->flags)&(3u<<(2*dn)), tmp, fd->tol);
                  } break;
                  findpt_pt_edge: {
                    const dfloat rh =
                      resid[0]*hes[hi0]+resid[1]*hes[6+hi0]+resid[2]*hes[12+hi0];
                    newton_edge(fpt, jac,rh,resid, de,dn1,dn2,
                                tmp->flags&(~(3u<<(2*de))), tmp, fd->tol);
                  } break;
#else
                  if(steep[0]<0) {
                    if(steep[1]<0){
                      newton_area(fpt, jac,resid, tmp, fd->tol);
                    }else {
                      const dfloat rh = resid[0]*hes[0]+resid[1]*hes[2+0];
                      newton_edge(fpt, jac,rh,resid, 0,1,
                                  tmp->flags&(3u<<(2*1)), tmp, fd->tol);
                    }
                  }else{
                    if(steep[1]<0) {
                      const dfloat rh = resid[0]*hes[1]+resid[1]*hes[2+1];
                      newton_edge(fpt, jac,rh,resid, 1,0,
                                  tmp->flags&(3u<<(2*0)), tmp, tol);
                    } else {
                      fpt->r[0]=tmp->r[0],fpt->r[1]=tmp->r[1];
                      fpt->dist2p=0;
                      fpt->flags = tmp->flags | CONVERGED_FLAG;
                    }
                  }
#endif
                  break;
                }
              }
              if (fpt->flags & CONVERGED_FLAG){
                break;
              }
              for(dlong j=0;j<INNER_SIZE;++j;@inner) if(j==0) *tmp=*fpt;
            }
          }

          bool converged_internal = (fpt->flags&FLAG_MASK)==CONVERGED_FLAG;
          if(*code_i==CODE_NOT_FOUND
             || converged_internal
             || fpt->dist2<*dist2_i) {
            for(dlong j=0;j<INNER_SIZE;++j;@inner) {
              if(j==0) {
                *el_i = el;
                *code_i = converged_internal ? CODE_INTERNAL : CODE_BORDER;
                *dist2_i = fpt->dist2;
              }
              if(j<p_D) r_i[j]=fpt->r[j];
            }
            if(converged_internal){
              break;
            }
          }
        }
      }
    }
  }
}
